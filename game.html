<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>My First Fortnite - Gift for My Nephew ‚ù§Ô∏è</title>
  <style>
    body { margin:0; overflow:hidden; font-family: Comic Sans MS, cursive; }
    #info {
      position: absolute; top: 10px; left: 10px; color: white;
      background: rgba(0,0,0,0.5); padding: 10px; border-radius: 10px;
      font-size: 20px;
    }
    #crosshair { position: absolute; top: 50%; left: 50%; font-size: 30px; color: white;
      transform: translate(-50%, -50%); pointer-events: none; }
    .score-popup {
      position: absolute;
      font-size: 48px;
      font-weight: bold;
      color: #ffff00;
      text-shadow: 3px 3px 0 #ff8800, -2px -2px 0 #000;
      pointer-events: none;
      animation: floatUp 2s ease-out forwards;
      z-index: 1000;
    }
    @keyframes floatUp {
      0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
      50% { opacity: 1; transform: translate(-50%, -150%) scale(1.2); }
      100% { opacity: 0; transform: translate(-50%, -250%) scale(0.8); }
    }
    /* Pause Menu Styles */
    #pauseMenu {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      z-index: 2000;
      justify-content: center;
      align-items: center;
    }
    #pauseMenu.active { display: flex; }
    .menu-box {
      background: linear-gradient(180deg, #4a4a4a 0%, #2d2d2d 100%);
      border: 4px solid #6b6b6b;
      border-radius: 0;
      padding: 30px 50px;
      min-width: 350px;
      box-shadow: 8px 8px 0 rgba(0,0,0,0.5);
      image-rendering: pixelated;
    }
    .menu-title {
      font-size: 32px;
      color: #fff;
      text-align: center;
      margin-bottom: 25px;
      text-shadow: 3px 3px 0 #000;
      letter-spacing: 2px;
    }
    .menu-setting {
      margin: 20px 0;
      color: #ddd;
      font-size: 18px;
    }
    .menu-setting label {
      display: block;
      margin-bottom: 8px;
    }
    .menu-setting input[type="range"] {
      width: 100%;
      height: 20px;
      -webkit-appearance: none;
      background: #555;
      border: 2px solid #888;
    }
    .menu-setting input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 30px;
      background: #8b8b8b;
      border: 2px solid #aaa;
      cursor: pointer;
    }
    .menu-btn {
      display: block;
      width: 100%;
      padding: 15px;
      margin: 10px 0;
      font-size: 20px;
      font-family: Comic Sans MS, cursive;
      background: linear-gradient(180deg, #5a5a5a 0%, #3a3a3a 100%);
      border: 3px solid #777;
      color: white;
      cursor: pointer;
      text-shadow: 2px 2px 0 #000;
    }
    .menu-btn:hover {
      background: linear-gradient(180deg, #7a7a7a 0%, #5a5a5a 100%);
      border-color: #999;
    }
    .setting-value {
      float: right;
      color: #ffff00;
    }
  </style>
</head>
<body>
  <div id="info">Arrows = Move ‚Ä¢ WASD/Mouse = Aim ‚Ä¢ Z = Shoot ‚Ä¢ Space = Jump ‚Ä¢ Esc = Menu<br>Score: <span id="score">0</span> üéØ</div>
  <div id="crosshair">+</div>

  <!-- Pause Menu -->
  <div id="pauseMenu">
    <div class="menu-box">
      <div class="menu-title">‚öôÔ∏è PAUSED ‚öôÔ∏è</div>
      
      <div class="menu-setting">
        <label>Aim Sensitivity <span class="setting-value" id="sensValue">2.0</span></label>
        <input type="range" id="sensitivitySlider" min="0.5" max="5" step="0.1" value="2">
      </div>

      <div class="menu-setting">
        <label>Crosshair Size <span class="setting-value" id="crosshairValue">30</span></label>
        <input type="range" id="crosshairSlider" min="15" max="60" step="1" value="30">
      </div>

      <button class="menu-btn" id="resumeBtn">‚ñ∂Ô∏è RESUME</button>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.168.0';
    import { PointerLockControls } from 'https://esm.sh/three@0.168.0/examples/jsm/controls/PointerLockControls.js';

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb); // sky blue
    scene.fog = new THREE.FogExp2(0x87ceeb, 0.002);

    const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Lock pointer when clicked (but not when paused or clicking menu)
    const controls = new PointerLockControls(camera, document.body);
    document.body.addEventListener('click', (e) => {
      if (!isPaused && !e.target.closest('#pauseMenu')) {
        controls.lock();
      }
    });

    // Simple ground
    const groundGeo = new THREE.PlaneGeometry(200, 200);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x3ab33a });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Track all blocks so we can break them!
    const blocks = [];
    const blockColors = [0xff00ff, 0x00ffff, 0xffff00, 0xff8800, 0x00ff00, 0xff0000, 0x0088ff];

    // Some colorful building blocks (easy to copy-paste more!)
    function makeBlock(x, z, color = 0xff0000) {
      const geo = new THREE.BoxGeometry(4, 4, 4);
      const mat = new THREE.MeshStandardMaterial({ color });
      const block = new THREE.Mesh(geo, mat);
      block.position.set(x, 2, z);
      block.castShadow = true;
      block.receiveShadow = true;
      scene.add(block);
      blocks.push(block); // Remember this block!
      return block;
    }

    // Spawn a new block at random spot
    function spawnRandomBlock() {
      const x = (Math.random() - 0.5) * 80;
      const z = -10 - Math.random() * 60;
      const color = blockColors[Math.floor(Math.random() * blockColors.length)];
      makeBlock(x, z, color);
    }

    makeBlock(10, -10, 0xff00ff);
    makeBlock(-10, -15, 0x00ffff);
    makeBlock(0, -20, 0xffff00);
    makeBlock(15, -25, 0xff8800);

    // Lights
    const sun = new THREE.DirectionalLight(0xffffff, 1.5);
    sun.position.set(50, 100, 50);
    sun.castShadow = true;
    scene.add(sun);
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));

    // Player stuff
    camera.position.set(0, 5, 10);
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, canJump = true;

    // ===== MINECRAFT-STYLE BLOCKY GUN =====
    const gun = new THREE.Group();
    
    // Gun body (main block)
    const gunBody = new THREE.Mesh(
      new THREE.BoxGeometry(0.15, 0.12, 0.4),
      new THREE.MeshStandardMaterial({ color: 0x4a4a4a })
    );
    gun.add(gunBody);
    
    // Gun barrel (front block)
    const gunBarrel = new THREE.Mesh(
      new THREE.BoxGeometry(0.08, 0.08, 0.25),
      new THREE.MeshStandardMaterial({ color: 0x333333 })
    );
    gunBarrel.position.set(0, 0.02, -0.3);
    gun.add(gunBarrel);
    
    // Gun handle (bottom block)
    const gunHandle = new THREE.Mesh(
      new THREE.BoxGeometry(0.1, 0.18, 0.12),
      new THREE.MeshStandardMaterial({ color: 0x8B4513 }) // Wood brown
    );
    gunHandle.position.set(0, -0.12, 0.08);
    gun.add(gunHandle);
    
    // Gun sight (top tiny block)
    const gunSight = new THREE.Mesh(
      new THREE.BoxGeometry(0.03, 0.04, 0.03),
      new THREE.MeshStandardMaterial({ color: 0x666666 })
    );
    gunSight.position.set(0, 0.08, -0.1);
    gun.add(gunSight);

    // Muzzle flash (hidden until shooting)
    const muzzleFlash = new THREE.Mesh(
      new THREE.BoxGeometry(0.15, 0.15, 0.1),
      new THREE.MeshBasicMaterial({ color: 0xffff00 })
    );
    muzzleFlash.position.set(0, 0.02, -0.45);
    muzzleFlash.visible = false;
    gun.add(muzzleFlash);

    // Position gun in bottom-right of view
    gun.position.set(0.35, -0.25, -0.5);
    gun.rotation.y = -0.1; // Slight angle
    camera.add(gun);
    scene.add(camera); // Need to add camera to scene for gun to render

    // Score tracking
    let score = 0;
    const scoreDisplay = document.getElementById('score');

    // Show floating "Score +1!" at explosion spot
    function showScorePopup(position3D) {
      // Convert 3D position to screen position
      const pos = position3D.clone();
      pos.project(camera);
      const x = (pos.x * 0.5 + 0.5) * window.innerWidth;
      const y = (-pos.y * 0.5 + 0.5) * window.innerHeight;

      // Create the popup
      const popup = document.createElement('div');
      popup.className = 'score-popup';
      popup.textContent = 'Score +1!';
      popup.style.left = x + 'px';
      popup.style.top = y + 'px';
      document.body.appendChild(popup);

      // Remove after animation (2 seconds)
      setTimeout(() => popup.remove(), 2000);
    }

    // Shooting!
    const bullets = [];
    function shoot() {
      const bullet = new THREE.Mesh(
        new THREE.SphereGeometry(0.3),
        new THREE.MeshBasicMaterial({ color: 0xffff00 })
      );
      bullet.position.copy(camera.position);
      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);
      bullet.velocity = dir.multiplyScalar(50);
      scene.add(bullet);
      bullets.push(bullet);

      // Muzzle flash!
      muzzleFlash.visible = true;
      muzzleFlash.material.color.setHex(0xffff00);
      setTimeout(() => {
        muzzleFlash.material.color.setHex(0xff8800);
        setTimeout(() => {
          muzzleFlash.visible = false;
        }, 30);
      }, 30);

      // Gun recoil animation
      gun.position.z += 0.05;
      gun.rotation.x -= 0.1;
      setTimeout(() => {
        gun.position.z = -0.5;
        gun.rotation.x = 0;
      }, 80);
    }

    // ===== GAME SETTINGS (expandable!) =====
    const settings = {
      aimSensitivity: 2,
      crosshairSize: 30,
      // Future settings can go here:
      // viewMode: 'first-person',
      // currentGun: 'pistol',
      // soundEnabled: true,
    };

    // Pause menu elements
    const pauseMenu = document.getElementById('pauseMenu');
    const resumeBtn = document.getElementById('resumeBtn');
    const sensitivitySlider = document.getElementById('sensitivitySlider');
    const crosshairSlider = document.getElementById('crosshairSlider');
    const sensValue = document.getElementById('sensValue');
    const crosshairValue = document.getElementById('crosshairValue');
    const crosshairEl = document.getElementById('crosshair');
    let isPaused = false;

    function togglePause() {
      isPaused = !isPaused;
      if (isPaused) {
        pauseMenu.classList.add('active');
        controls.unlock();
      } else {
        pauseMenu.classList.remove('active');
        controls.lock();
      }
    }

    // Settings sliders
    sensitivitySlider.addEventListener('input', (e) => {
      settings.aimSensitivity = parseFloat(e.target.value);
      sensValue.textContent = settings.aimSensitivity.toFixed(1);
    });

    crosshairSlider.addEventListener('input', (e) => {
      settings.crosshairSize = parseInt(e.target.value);
      crosshairValue.textContent = settings.crosshairSize;
      crosshairEl.style.fontSize = settings.crosshairSize + 'px';
    });

    resumeBtn.addEventListener('click', () => {
      togglePause();
    });

    // WASD aiming (rotate camera)
    let aimUp = false, aimDown = false, aimLeft = false, aimRight = false;

    // Controls
    document.addEventListener('keydown', e => {
      // Pause menu toggle (works anytime)
      if (e.code === 'Escape' || e.code === 'KeyP') {
        togglePause();
        return;
      }

      // Don't process game controls if paused
      if (isPaused) return;

      switch (e.code) {
        // Arrow keys = MOVE
        case 'ArrowUp': moveForward = true; break;
        case 'ArrowDown': moveBackward = true; break;
        case 'ArrowLeft': moveLeft = true; break;
        case 'ArrowRight': moveRight = true; break;
        // WASD = AIM (rotate view)
        case 'KeyW': aimUp = true; break;
        case 'KeyS': aimDown = true; break;
        case 'KeyA': aimLeft = true; break;
        case 'KeyD': aimRight = true; break;
        // Jump
        case 'Space': if (canJump) velocity.y += 18; canJump = false; break;
        // Shoot with Z key!
        case 'KeyZ': if (controls.isLocked) shoot(); break;
      }
    });
    document.addEventListener('keyup', e => {
      switch (e.code) {
        // Arrow keys = MOVE
        case 'ArrowUp': moveForward = false; break;
        case 'ArrowDown': moveBackward = false; break;
        case 'ArrowLeft': moveLeft = false; break;
        case 'ArrowRight': moveRight = false; break;
        // WASD = AIM
        case 'KeyW': aimUp = false; break;
        case 'KeyS': aimDown = false; break;
        case 'KeyA': aimLeft = false; break;
        case 'KeyD': aimRight = false; break;
      }
    });
    document.addEventListener('click', (e) => {
      // Don't shoot if clicking menu or paused
      if (isPaused || e.target.closest('#pauseMenu')) return;
      if (controls.isLocked) shoot();
    });

    // Animation loop
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      if (controls.isLocked && !isPaused) {
        // WASD aiming - rotate the camera view (uses settings!)
        const aimSpeed = settings.aimSensitivity;
        if (aimLeft) camera.rotation.y += aimSpeed * delta;
        if (aimRight) camera.rotation.y -= aimSpeed * delta;
        if (aimUp) camera.rotation.x += aimSpeed * delta;
        if (aimDown) camera.rotation.x -= aimSpeed * delta;
        // Clamp vertical look so you can't flip upside down
        camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));

        // Arrow key movement
        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.normalize();

        velocity.x -= velocity.x * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;
        velocity.y -= 25.0 * delta; // gravity

        if (direction.z || direction.x) {
          controls.moveRight(direction.x * 20 * delta);
          controls.moveForward(direction.z * 20 * delta);
        }

        camera.position.y += velocity.y * delta;
        if (camera.position.y < 5) {
          velocity.y = 0;
          camera.position.y = 5;
          canJump = true;
        }
      }

      // Update bullets and check for hits!
      for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];
        bullet.position.addScaledVector(bullet.velocity, delta);

        // Check if bullet hit any block
        for (let j = blocks.length - 1; j >= 0; j--) {
          const block = blocks[j];
          if (bullet.position.distanceTo(block.position) < 2.5) {
            // BOOM! Make sparkles fly out like sprinkles!
            for (let s = 0; s < 8; s++) {
              const spark = new THREE.Mesh(
                new THREE.SphereGeometry(0.3),
                new THREE.MeshBasicMaterial({ color: 0xffff00 })
              );
              spark.position.copy(block.position);
              scene.add(spark);
              
              // Each spark flies in random direction
              const sparkVel = new THREE.Vector3(
                (Math.random() - 0.5) * 15,
                Math.random() * 10,
                (Math.random() - 0.5) * 15
              );
              spark.userData.vel = sparkVel;
              spark.userData.life = 0;
              
              // Animate the spark
              const sparkTimer = setInterval(() => {
                spark.position.add(spark.userData.vel.clone().multiplyScalar(0.05));
                spark.userData.vel.y -= 0.5; // gravity on sparks
                spark.userData.life++;
                if (spark.userData.life > 20) {
                  scene.remove(spark);
                  clearInterval(sparkTimer);
                }
              }, 50);
            }

            // Remove block and bullet
            scene.remove(block);
            blocks.splice(j, 1);
            scene.remove(bullet);
            bullets.splice(i, 1);

            // Update score!
            score++;
            scoreDisplay.textContent = score;

            // Show big floating "Score +1!" at explosion!
            showScorePopup(block.position);

            // Spawn a new block after 1 second
            setTimeout(spawnRandomBlock, 1000);
            break;
          }
        }

        // Remove bullets that fly too far
        if (bullet.position.length() > 200) {
          scene.remove(bullet);
          bullets.splice(i, 1);
        }
      }

      renderer.render(scene, camera);
    }
    animate();

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>