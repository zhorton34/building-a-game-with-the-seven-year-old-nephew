<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>My First Fortnite - Gift for My Nephew ‚ù§Ô∏è</title>
  <style>
    body { margin:0; overflow:hidden; font-family: Comic Sans MS, cursive; }
    #info {
      position: absolute; top: 10px; left: 10px; color: white;
      background: rgba(0,0,0,0.5); padding: 10px; border-radius: 10px;
      font-size: 20px;
    }
    #crosshair { position: absolute; top: 50%; left: 50%; font-size: 30px; color: white;
      transform: translate(-50%, -50%); pointer-events: none; }
    .score-popup {
      position: absolute;
      font-size: 48px;
      font-weight: bold;
      color: #ffff00;
      text-shadow: 3px 3px 0 #ff8800, -2px -2px 0 #000;
      pointer-events: none;
      animation: floatUp 2s ease-out forwards;
      z-index: 1000;
    }
    @keyframes floatUp {
      0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
      50% { opacity: 1; transform: translate(-50%, -150%) scale(1.2); }
      100% { opacity: 0; transform: translate(-50%, -250%) scale(0.8); }
    }
    /* Pause Menu Styles */
    #pauseMenu {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      z-index: 2000;
      justify-content: center;
      align-items: center;
    }
    #pauseMenu.active { display: flex; }
    .menu-box {
      background: linear-gradient(180deg, #4a4a4a 0%, #2d2d2d 100%);
      border: 4px solid #6b6b6b;
      border-radius: 0;
      padding: 30px 50px;
      min-width: 350px;
      box-shadow: 8px 8px 0 rgba(0,0,0,0.5);
      image-rendering: pixelated;
    }
    .menu-title {
      font-size: 32px;
      color: #fff;
      text-align: center;
      margin-bottom: 25px;
      text-shadow: 3px 3px 0 #000;
      letter-spacing: 2px;
    }
    .menu-setting {
      margin: 20px 0;
      color: #ddd;
      font-size: 18px;
    }
    .menu-setting label {
      display: block;
      margin-bottom: 8px;
    }
    .menu-setting input[type="range"] {
      width: 100%;
      height: 20px;
      -webkit-appearance: none;
      background: #555;
      border: 2px solid #888;
    }
    .menu-setting input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 30px;
      background: #8b8b8b;
      border: 2px solid #aaa;
      cursor: pointer;
    }
    .menu-btn {
      display: block;
      width: 100%;
      padding: 15px;
      margin: 10px 0;
      font-size: 20px;
      font-family: Comic Sans MS, cursive;
      background: linear-gradient(180deg, #5a5a5a 0%, #3a3a3a 100%);
      border: 3px solid #777;
      color: white;
      cursor: pointer;
      text-shadow: 2px 2px 0 #000;
    }
    .menu-btn:hover {
      background: linear-gradient(180deg, #7a7a7a 0%, #5a5a5a 100%);
      border-color: #999;
    }
    .setting-value {
      float: right;
      color: #ffff00;
    }
    /* ===== INVENTORY HOTBAR ===== */
    #hotbar {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 4px;
      z-index: 100;
    }
    .hotbar-slot {
      width: 50px;
      height: 50px;
      background: rgba(50, 50, 50, 0.8);
      border: 3px solid #555;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      image-rendering: pixelated;
    }
    .hotbar-slot.selected {
      border-color: #fff;
      background: rgba(80, 80, 80, 0.9);
      box-shadow: 0 0 10px rgba(255,255,255,0.5);
    }
    .hotbar-slot .slot-num {
      position: absolute;
      top: 2px;
      left: 4px;
      font-size: 10px;
      color: #aaa;
    }
    .hotbar-slot .item-icon {
      width: 30px;
      height: 30px;
      margin-top: 5px;
    }
    .hotbar-slot .item-count {
      position: absolute;
      bottom: 2px;
      right: 4px;
      font-size: 12px;
      color: #fff;
      text-shadow: 1px 1px 0 #000;
    }
  </style>
</head>
<body>
  <div id="info">Arrows = Move ‚Ä¢ WASD/Mouse = Aim ‚Ä¢ Z = Shoot ‚Ä¢ Space = Jump ‚Ä¢ Esc = Menu<br>Score: <span id="score">0</span> üéØ</div>
  <div id="crosshair">+</div>

  <!-- Inventory Hotbar -->
  <div id="hotbar">
    <div class="hotbar-slot selected" data-slot="1"><span class="slot-num">1</span></div>
    <div class="hotbar-slot" data-slot="2"><span class="slot-num">2</span></div>
    <div class="hotbar-slot" data-slot="3"><span class="slot-num">3</span></div>
    <div class="hotbar-slot" data-slot="4"><span class="slot-num">4</span></div>
    <div class="hotbar-slot" data-slot="5"><span class="slot-num">5</span></div>
    <div class="hotbar-slot" data-slot="6"><span class="slot-num">6</span></div>
    <div class="hotbar-slot" data-slot="7"><span class="slot-num">7</span></div>
    <div class="hotbar-slot" data-slot="8"><span class="slot-num">8</span></div>
    <div class="hotbar-slot" data-slot="9"><span class="slot-num">9</span></div>
  </div>

  <!-- Pause Menu -->
  <div id="pauseMenu">
    <div class="menu-box">
      <div class="menu-title">‚öôÔ∏è PAUSED ‚öôÔ∏è</div>
      
      <div class="menu-setting">
        <label>Aim Sensitivity <span class="setting-value" id="sensValue">2.0</span></label>
        <input type="range" id="sensitivitySlider" min="0.5" max="5" step="0.1" value="2">
      </div>

      <div class="menu-setting">
        <label>Crosshair Size <span class="setting-value" id="crosshairValue">30</span></label>
        <input type="range" id="crosshairSlider" min="15" max="60" step="1" value="30">
      </div>

      <button class="menu-btn" id="resumeBtn">‚ñ∂Ô∏è RESUME</button>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.168.0';
    import { PointerLockControls } from 'https://esm.sh/three@0.168.0/examples/jsm/controls/PointerLockControls.js';

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb); // sky blue
    scene.fog = new THREE.FogExp2(0x87ceeb, 0.002);

    const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Lock pointer when clicked (but not when paused or clicking menu)
    const controls = new PointerLockControls(camera, document.body);
    document.body.addEventListener('click', (e) => {
      if (!isPaused && !e.target.closest('#pauseMenu')) {
        controls.lock();
      }
    });

    // Simple ground
    const groundGeo = new THREE.PlaneGeometry(200, 200);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x3ab33a });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Track all blocks so we can break them!
    const blocks = [];
    const blockColors = [0xff00ff, 0x00ffff, 0xffff00, 0xff8800, 0x00ff00, 0xff0000, 0x0088ff];

    // Some colorful building blocks (easy to copy-paste more!)
    function makeBlock(x, z, color = 0xff0000) {
      const geo = new THREE.BoxGeometry(4, 4, 4);
      const mat = new THREE.MeshStandardMaterial({ color });
      const block = new THREE.Mesh(geo, mat);
      block.position.set(x, 2, z);
      block.castShadow = true;
      block.receiveShadow = true;
      scene.add(block);
      blocks.push(block); // Remember this block!
      return block;
    }

    // Spawn a new block at random spot
    function spawnRandomBlock() {
      const x = (Math.random() - 0.5) * 80;
      const z = -10 - Math.random() * 60;
      const color = blockColors[Math.floor(Math.random() * blockColors.length)];
      makeBlock(x, z, color);
    }

    makeBlock(10, -10, 0xff00ff);
    makeBlock(-10, -15, 0x00ffff);
    makeBlock(0, -20, 0xffff00);
    makeBlock(15, -25, 0xff8800);

    // ===== PHASE 1: MINECRAFT-STYLE TREES =====
    // Trees are groups of blocks (trunk + leaves) that can be destroyed
    const trees = []; // Track all trees for collision/destruction
    const treeParts = []; // Individual blocks that make up trees (for shooting)

    /**
     * Creates a Minecraft-style tree at position (x, z)
     * @param {number} x - X position
     * @param {number} z - Z position  
     * @param {number} trunkHeight - Height of trunk (default 3)
     * @returns {THREE.Group} The tree group
     */
    function makeTree(x, z, trunkHeight = 3) {
      const tree = new THREE.Group();
      tree.userData.type = 'tree'; // For identification
      
      // Trunk - brown wooden blocks stacked
      const trunkColor = 0x8B4513; // Saddle brown (wood)
      for (let y = 0; y < trunkHeight; y++) {
        const trunk = new THREE.Mesh(
          new THREE.BoxGeometry(2, 2, 2),
          new THREE.MeshStandardMaterial({ color: trunkColor })
        );
        trunk.position.set(0, 1 + y * 2, 0);
        trunk.castShadow = true;
        trunk.receiveShadow = true;
        trunk.userData.type = 'trunk';
        trunk.userData.parentTree = tree;
        tree.add(trunk);
        treeParts.push(trunk);
      }
      
      // Leaves - green blocks in a cross/cluster pattern on top
      const leafColor = 0x228B22; // Forest green
      const leafY = trunkHeight * 2 + 1; // Top of trunk
      const leafPositions = [
        // Top layer
        [0, leafY + 2, 0],
        // Middle layer (cross pattern)
        [0, leafY, 0],
        [2, leafY, 0], [-2, leafY, 0],
        [0, leafY, 2], [0, leafY, -2],
        // Corner leaves
        [2, leafY, 2], [-2, leafY, 2],
        [2, leafY, -2], [-2, leafY, -2],
      ];
      
      leafPositions.forEach(pos => {
        const leaf = new THREE.Mesh(
          new THREE.BoxGeometry(2, 2, 2),
          new THREE.MeshStandardMaterial({ color: leafColor })
        );
        leaf.position.set(pos[0], pos[1], pos[2]);
        leaf.castShadow = true;
        leaf.receiveShadow = true;
        leaf.userData.type = 'leaf';
        leaf.userData.parentTree = tree;
        tree.add(leaf);
        treeParts.push(leaf);
      });
      
      // Position the whole tree
      tree.position.set(x, 0, z);
      scene.add(tree);
      trees.push(tree);
      
      return tree;
    }

    // Spawn trees around the map (away from player start at 0,0)
    const treePositions = [
      [-30, -20], [35, -25], [-25, -45], [40, -50],
      [-45, -35], [25, -60], [-15, -55], [50, -30],
    ];
    treePositions.forEach(pos => makeTree(pos[0], pos[1]));

    // ===== END PHASE 1 =====

    // ===== PHASE 2: CAVES =====
    // Caves are dark stone structures with entrances
    const caves = [];
    const caveParts = []; // Stone blocks that can be shot

    /**
     * Creates a cave entrance at position (x, z)
     * @param {number} x - X position
     * @param {number} z - Z position
     * @param {number} rotation - Rotation in radians (which way entrance faces)
     */
    function makeCave(x, z, rotation = 0) {
      const cave = new THREE.Group();
      cave.userData.type = 'cave';
      
      const stoneColor = 0x555555; // Dark gray stone
      const stoneDarkColor = 0x333333; // Even darker for depth
      
      // Cave frame - arch-like entrance
      const stonePositions = [
        // Left pillar
        [-3, 1, 0], [-3, 3, 0], [-3, 5, 0],
        // Right pillar  
        [3, 1, 0], [3, 3, 0], [3, 5, 0],
        // Top arch
        [-2, 7, 0], [0, 7, 0], [2, 7, 0],
        [-1, 8, 0], [1, 8, 0], [0, 9, 0],
        // Back wall (darker)
        [-3, 1, -4], [-1, 1, -4], [1, 1, -4], [3, 1, -4],
        [-3, 3, -4], [-1, 3, -4], [1, 3, -4], [3, 3, -4],
        [-2, 5, -4], [0, 5, -4], [2, 5, -4],
        // Side walls
        [-3, 1, -2], [-3, 3, -2], [3, 1, -2], [3, 3, -2],
        // Roof
        [-2, 7, -2], [0, 7, -2], [2, 7, -2],
      ];
      
      stonePositions.forEach((pos, i) => {
        const isBackWall = pos[2] < -2;
        const stone = new THREE.Mesh(
          new THREE.BoxGeometry(2, 2, 2),
          new THREE.MeshStandardMaterial({ 
            color: isBackWall ? stoneDarkColor : stoneColor 
          })
        );
        stone.position.set(pos[0], pos[1], pos[2]);
        stone.castShadow = true;
        stone.receiveShadow = true;
        stone.userData.type = 'stone';
        stone.userData.parentCave = cave;
        cave.add(stone);
        caveParts.push(stone);
      });
      
      // Add a special glowing block inside the cave (treasure!)
      const treasureColors = [0xff00ff, 0x00ffff, 0xffff00, 0xff0000];
      const treasure = new THREE.Mesh(
        new THREE.BoxGeometry(1.5, 1.5, 1.5),
        new THREE.MeshStandardMaterial({ 
          color: treasureColors[Math.floor(Math.random() * treasureColors.length)],
          emissive: 0x222222,
        })
      );
      treasure.position.set(0, 1, -3);
      treasure.userData.type = 'treasure';
      treasure.userData.parentCave = cave;
      cave.add(treasure);
      caveParts.push(treasure);
      
      // Position and rotate the cave
      cave.position.set(x, 0, z);
      cave.rotation.y = rotation;
      scene.add(cave);
      caves.push(cave);
      
      return cave;
    }

    // Spawn a few caves around the edges of the map
    makeCave(-60, -40, Math.PI * 0.1);  // Left side, facing slightly right
    makeCave(55, -55, Math.PI * 0.8);   // Right side, facing left-ish
    makeCave(0, -75, 0);                // Far back, facing player

    // ===== END PHASE 2 =====

    // ===== PHASE 3: WATER =====
    // A beautiful blue lake with gentle animation
    
    /**
     * Creates a water body at position (x, z)
     * @param {number} x - Center X position
     * @param {number} z - Center Z position
     * @param {number} width - Width of water
     * @param {number} depth - Depth (Z direction) of water
     */
    function makeWater(x, z, width = 30, depth = 20) {
      const waterGeo = new THREE.PlaneGeometry(width, depth, 20, 20);
      const waterMat = new THREE.MeshStandardMaterial({
        color: 0x0077be,        // Ocean blue
        transparent: true,
        opacity: 0.7,
        side: THREE.DoubleSide,
      });
      
      const water = new THREE.Mesh(waterGeo, waterMat);
      water.rotation.x = -Math.PI / 2;
      water.position.set(x, 0.3, z); // Slightly above ground
      water.userData.type = 'water';
      water.userData.time = 0;
      water.userData.originalY = 0.3;
      scene.add(water);
      
      return water;
    }

    // Create a lake on one side of the map
    const lake = makeWater(-35, -60, 35, 25);

    // Animate water (gentle bobbing)
    function animateWater(delta) {
      if (lake) {
        lake.userData.time += delta;
        // Gentle up/down motion
        lake.position.y = lake.userData.originalY + Math.sin(lake.userData.time * 2) * 0.15;
        
        // Also animate vertices for wave effect
        const positions = lake.geometry.attributes.position;
        for (let i = 0; i < positions.count; i++) {
          const x = positions.getX(i);
          const z = positions.getZ(i);
          // Create wave pattern
          const wave = Math.sin(x * 0.5 + lake.userData.time * 3) * 0.2 +
                       Math.sin(z * 0.3 + lake.userData.time * 2) * 0.15;
          positions.setY(i, wave);
        }
        positions.needsUpdate = true;
      }
    }

    // ===== END PHASE 3 =====

    // Lights
    const sun = new THREE.DirectionalLight(0xffffff, 1.5);
    sun.position.set(50, 100, 50);
    sun.castShadow = true;
    scene.add(sun);
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));

    // Player stuff
    camera.position.set(0, 5, 10);
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, canJump = true;

    // ===== MINECRAFT-STYLE BLOCKY GUN =====
    const gun = new THREE.Group();
    
    // Gun body (main block)
    const gunBody = new THREE.Mesh(
      new THREE.BoxGeometry(0.15, 0.12, 0.4),
      new THREE.MeshStandardMaterial({ color: 0x4a4a4a })
    );
    gun.add(gunBody);
    
    // Gun barrel (front block)
    const gunBarrel = new THREE.Mesh(
      new THREE.BoxGeometry(0.08, 0.08, 0.25),
      new THREE.MeshStandardMaterial({ color: 0x333333 })
    );
    gunBarrel.position.set(0, 0.02, -0.3);
    gun.add(gunBarrel);
    
    // Gun handle (bottom block)
    const gunHandle = new THREE.Mesh(
      new THREE.BoxGeometry(0.1, 0.18, 0.12),
      new THREE.MeshStandardMaterial({ color: 0x8B4513 }) // Wood brown
    );
    gunHandle.position.set(0, -0.12, 0.08);
    gun.add(gunHandle);
    
    // Gun sight (top tiny block)
    const gunSight = new THREE.Mesh(
      new THREE.BoxGeometry(0.03, 0.04, 0.03),
      new THREE.MeshStandardMaterial({ color: 0x666666 })
    );
    gunSight.position.set(0, 0.08, -0.1);
    gun.add(gunSight);

    // Muzzle flash (hidden until shooting)
    const muzzleFlash = new THREE.Mesh(
      new THREE.BoxGeometry(0.15, 0.15, 0.1),
      new THREE.MeshBasicMaterial({ color: 0xffff00 })
    );
    muzzleFlash.position.set(0, 0.02, -0.45);
    muzzleFlash.visible = false;
    gun.add(muzzleFlash);

    // Position gun in bottom-right of view
    gun.position.set(0.35, -0.25, -0.5);
    gun.rotation.y = -0.1; // Slight angle
    camera.add(gun);
    scene.add(camera); // Need to add camera to scene for gun to render

    // Score tracking
    let score = 0;
    const scoreDisplay = document.getElementById('score');

    // Show floating "Score +1!" at explosion spot
    function showScorePopup(position3D) {
      // Convert 3D position to screen position
      const pos = position3D.clone();
      pos.project(camera);
      const x = (pos.x * 0.5 + 0.5) * window.innerWidth;
      const y = (-pos.y * 0.5 + 0.5) * window.innerHeight;

      // Create the popup
      const popup = document.createElement('div');
      popup.className = 'score-popup';
      popup.textContent = 'Score +1!';
      popup.style.left = x + 'px';
      popup.style.top = y + 'px';
      document.body.appendChild(popup);

      // Remove after animation (2 seconds)
      setTimeout(() => popup.remove(), 2000);
    }

    // Shooting!
    const bullets = [];
    function shoot() {
      const bullet = new THREE.Mesh(
        new THREE.SphereGeometry(0.3),
        new THREE.MeshBasicMaterial({ color: 0xffff00 })
      );
      bullet.position.copy(camera.position);
      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);
      bullet.velocity = dir.multiplyScalar(50);
      scene.add(bullet);
      bullets.push(bullet);

      // Muzzle flash!
      muzzleFlash.visible = true;
      muzzleFlash.material.color.setHex(0xffff00);
      setTimeout(() => {
        muzzleFlash.material.color.setHex(0xff8800);
        setTimeout(() => {
          muzzleFlash.visible = false;
        }, 30);
      }, 30);

      // Gun recoil animation
      gun.position.z += 0.05;
      gun.rotation.x -= 0.1;
      setTimeout(() => {
        gun.position.z = -0.5;
        gun.rotation.x = 0;
      }, 80);
    }

    // ===== PHASE 4: INVENTORY SYSTEM =====
    // Expandable inventory with hotbar UI
    
    // Item definitions (easy to add more!)
    const itemTypes = {
      wood: { name: 'Wood', color: '#8B4513', icon: 'ü™µ' },
      stone: { name: 'Stone', color: '#555555', icon: 'ü™®' },
      leaves: { name: 'Leaves', color: '#228B22', icon: 'üçÉ' },
      treasure: { name: 'Treasure', color: '#ffd700', icon: 'üíé' },
      dirt: { name: 'Dirt', color: '#8B5A2B', icon: 'üü´' },
    };

    // Inventory state
    const inventory = {
      slots: [
        null, null, null, null, null, null, null, null, null // 9 slots (index 0-8)
      ],
      selectedSlot: 0, // Currently selected slot (0-8)
    };

    // Get hotbar DOM elements
    const hotbarSlots = document.querySelectorAll('.hotbar-slot');

    /**
     * Select a hotbar slot (0-8)
     */
    function selectSlot(slotIndex) {
      if (slotIndex < 0 || slotIndex > 8) return;
      
      // Update state
      inventory.selectedSlot = slotIndex;
      
      // Update UI
      hotbarSlots.forEach((slot, i) => {
        slot.classList.toggle('selected', i === slotIndex);
      });
    }

    /**
     * Add item to inventory (finds first empty slot or stacks)
     * @returns {boolean} true if item was added
     */
    function addToInventory(itemType, count = 1) {
      // First try to stack with existing items
      for (let i = 0; i < inventory.slots.length; i++) {
        const slot = inventory.slots[i];
        if (slot && slot.type === itemType) {
          slot.count += count;
          updateHotbarUI();
          return true;
        }
      }
      
      // Find first empty slot
      for (let i = 0; i < inventory.slots.length; i++) {
        if (!inventory.slots[i]) {
          inventory.slots[i] = { type: itemType, count };
          updateHotbarUI();
          return true;
        }
      }
      
      return false; // Inventory full
    }

    /**
     * Update the hotbar UI to match inventory state
     */
    function updateHotbarUI() {
      hotbarSlots.forEach((slotEl, i) => {
        const slotData = inventory.slots[i];
        
        // Remove old content (except slot number)
        const oldIcon = slotEl.querySelector('.item-icon');
        const oldCount = slotEl.querySelector('.item-count');
        if (oldIcon) oldIcon.remove();
        if (oldCount) oldCount.remove();
        
        if (slotData) {
          const itemDef = itemTypes[slotData.type];
          if (itemDef) {
            // Add icon
            const icon = document.createElement('div');
            icon.className = 'item-icon';
            icon.textContent = itemDef.icon;
            icon.style.fontSize = '24px';
            slotEl.appendChild(icon);
            
            // Add count
            const count = document.createElement('span');
            count.className = 'item-count';
            count.textContent = slotData.count;
            slotEl.appendChild(count);
          }
        }
      });
    }

    // Initialize with some starting items (for testing)
    addToInventory('wood', 5);
    addToInventory('stone', 3);

    // ===== END PHASE 4 =====

    // ===== GAME SETTINGS (expandable!) =====
    const settings = {
      aimSensitivity: 2,
      crosshairSize: 30,
      // Future settings can go here:
      // viewMode: 'first-person',
      // currentGun: 'pistol',
      // soundEnabled: true,
    };

    // Pause menu elements
    const pauseMenu = document.getElementById('pauseMenu');
    const resumeBtn = document.getElementById('resumeBtn');
    const sensitivitySlider = document.getElementById('sensitivitySlider');
    const crosshairSlider = document.getElementById('crosshairSlider');
    const sensValue = document.getElementById('sensValue');
    const crosshairValue = document.getElementById('crosshairValue');
    const crosshairEl = document.getElementById('crosshair');
    let isPaused = false;

    function togglePause() {
      isPaused = !isPaused;
      if (isPaused) {
        pauseMenu.classList.add('active');
        controls.unlock();
      } else {
        pauseMenu.classList.remove('active');
        controls.lock();
      }
    }

    // Settings sliders
    sensitivitySlider.addEventListener('input', (e) => {
      settings.aimSensitivity = parseFloat(e.target.value);
      sensValue.textContent = settings.aimSensitivity.toFixed(1);
    });

    crosshairSlider.addEventListener('input', (e) => {
      settings.crosshairSize = parseInt(e.target.value);
      crosshairValue.textContent = settings.crosshairSize;
      crosshairEl.style.fontSize = settings.crosshairSize + 'px';
    });

    resumeBtn.addEventListener('click', () => {
      togglePause();
    });

    // WASD aiming (rotate camera)
    let aimUp = false, aimDown = false, aimLeft = false, aimRight = false;

    // Controls
    document.addEventListener('keydown', e => {
      // Pause menu toggle (works anytime)
      if (e.code === 'Escape' || e.code === 'KeyP') {
        togglePause();
        return;
      }

      // Don't process game controls if paused
      if (isPaused) return;

      switch (e.code) {
        // Arrow keys = MOVE
        case 'ArrowUp': moveForward = true; break;
        case 'ArrowDown': moveBackward = true; break;
        case 'ArrowLeft': moveLeft = true; break;
        case 'ArrowRight': moveRight = true; break;
        // WASD = AIM (rotate view)
        case 'KeyW': aimUp = true; break;
        case 'KeyS': aimDown = true; break;
        case 'KeyA': aimLeft = true; break;
        case 'KeyD': aimRight = true; break;
        // Jump
        case 'Space': if (canJump) velocity.y += 18; canJump = false; break;
        // Shoot with Z key!
        case 'KeyZ': if (controls.isLocked) shoot(); break;
        // Hotbar selection (1-9)
        case 'Digit1': selectSlot(0); break;
        case 'Digit2': selectSlot(1); break;
        case 'Digit3': selectSlot(2); break;
        case 'Digit4': selectSlot(3); break;
        case 'Digit5': selectSlot(4); break;
        case 'Digit6': selectSlot(5); break;
        case 'Digit7': selectSlot(6); break;
        case 'Digit8': selectSlot(7); break;
        case 'Digit9': selectSlot(8); break;
      }
    });
    document.addEventListener('keyup', e => {
      switch (e.code) {
        // Arrow keys = MOVE
        case 'ArrowUp': moveForward = false; break;
        case 'ArrowDown': moveBackward = false; break;
        case 'ArrowLeft': moveLeft = false; break;
        case 'ArrowRight': moveRight = false; break;
        // WASD = AIM
        case 'KeyW': aimUp = false; break;
        case 'KeyS': aimDown = false; break;
        case 'KeyA': aimLeft = false; break;
        case 'KeyD': aimRight = false; break;
      }
    });
    document.addEventListener('click', (e) => {
      // Don't shoot if clicking menu or paused
      if (isPaused || e.target.closest('#pauseMenu')) return;
      if (controls.isLocked) shoot();
    });

    // Animation loop
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      // Animate water (always runs, even when paused - looks nice!)
      animateWater(delta);

      if (controls.isLocked && !isPaused) {
        // WASD aiming - rotate the camera view (uses settings!)
        const aimSpeed = settings.aimSensitivity;
        if (aimLeft) camera.rotation.y += aimSpeed * delta;
        if (aimRight) camera.rotation.y -= aimSpeed * delta;
        if (aimUp) camera.rotation.x += aimSpeed * delta;
        if (aimDown) camera.rotation.x -= aimSpeed * delta;
        // Clamp vertical look so you can't flip upside down
        camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));

        // Arrow key movement
        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.normalize();

        velocity.x -= velocity.x * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;
        velocity.y -= 25.0 * delta; // gravity

        if (direction.z || direction.x) {
          controls.moveRight(direction.x * 20 * delta);
          controls.moveForward(direction.z * 20 * delta);
        }

        camera.position.y += velocity.y * delta;
        if (camera.position.y < 5) {
          velocity.y = 0;
          camera.position.y = 5;
          canJump = true;
        }
      }

      // Update bullets and check for hits!
      for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];
        bullet.position.addScaledVector(bullet.velocity, delta);

        // Check if bullet hit any block
        for (let j = blocks.length - 1; j >= 0; j--) {
          const block = blocks[j];
          if (bullet.position.distanceTo(block.position) < 2.5) {
            // BOOM! Make sparkles fly out like sprinkles!
            for (let s = 0; s < 8; s++) {
              const spark = new THREE.Mesh(
                new THREE.SphereGeometry(0.3),
                new THREE.MeshBasicMaterial({ color: 0xffff00 })
              );
              spark.position.copy(block.position);
              scene.add(spark);
              
              // Each spark flies in random direction
              const sparkVel = new THREE.Vector3(
                (Math.random() - 0.5) * 15,
                Math.random() * 10,
                (Math.random() - 0.5) * 15
              );
              spark.userData.vel = sparkVel;
              spark.userData.life = 0;
              
              // Animate the spark
              const sparkTimer = setInterval(() => {
                spark.position.add(spark.userData.vel.clone().multiplyScalar(0.05));
                spark.userData.vel.y -= 0.5; // gravity on sparks
                spark.userData.life++;
                if (spark.userData.life > 20) {
                  scene.remove(spark);
                  clearInterval(sparkTimer);
                }
              }, 50);
            }

            // Remove block and bullet
            scene.remove(block);
            blocks.splice(j, 1);
            scene.remove(bullet);
            bullets.splice(i, 1);

            // Update score!
            score++;
            scoreDisplay.textContent = score;

            // Show big floating "Score +1!" at explosion!
            showScorePopup(block.position);

            // Spawn a new block after 1 second
            setTimeout(spawnRandomBlock, 1000);
            break;
          }
        }

        // Check if bullet hit any tree part (trunk or leaf)
        for (let t = treeParts.length - 1; t >= 0; t--) {
          const part = treeParts[t];
          if (!part.parent) continue; // Already removed
          
          // Get world position of the tree part
          const partWorldPos = new THREE.Vector3();
          part.getWorldPosition(partWorldPos);
          
          if (bullet.position.distanceTo(partWorldPos) < 1.5) {
            // Determine spark color based on part type
            const sparkColor = part.userData.type === 'leaf' ? 0x228B22 : 0x8B4513;
            
            // Explosion sparks!
            for (let s = 0; s < 6; s++) {
              const spark = new THREE.Mesh(
                new THREE.SphereGeometry(0.2),
                new THREE.MeshBasicMaterial({ color: sparkColor })
              );
              spark.position.copy(partWorldPos);
              scene.add(spark);
              
              const sparkVel = new THREE.Vector3(
                (Math.random() - 0.5) * 10,
                Math.random() * 8,
                (Math.random() - 0.5) * 10
              );
              spark.userData.vel = sparkVel;
              spark.userData.life = 0;
              
              const sparkTimer = setInterval(() => {
                spark.position.add(spark.userData.vel.clone().multiplyScalar(0.05));
                spark.userData.vel.y -= 0.4;
                spark.userData.life++;
                if (spark.userData.life > 15) {
                  scene.remove(spark);
                  clearInterval(sparkTimer);
                }
              }, 50);
            }

            // Remove the tree part
            const parentTree = part.userData.parentTree;
            if (parentTree) {
              parentTree.remove(part);
            }
            treeParts.splice(t, 1);
            
            // Remove bullet
            scene.remove(bullet);
            bullets.splice(i, 1);

            // Score for tree parts too!
            score++;
            scoreDisplay.textContent = score;
            showScorePopup(partWorldPos);
            
            break;
          }
        }

        // Check if bullet hit any cave part (stone or treasure)
        for (let c = caveParts.length - 1; c >= 0; c--) {
          const part = caveParts[c];
          if (!part.parent) continue; // Already removed
          
          const partWorldPos = new THREE.Vector3();
          part.getWorldPosition(partWorldPos);
          
          if (bullet.position.distanceTo(partWorldPos) < 1.5) {
            // Different effects for stone vs treasure
            const isTreasure = part.userData.type === 'treasure';
            const sparkColor = isTreasure ? 0xffd700 : 0x888888; // Gold or gray
            const sparkCount = isTreasure ? 12 : 5;
            
            for (let s = 0; s < sparkCount; s++) {
              const spark = new THREE.Mesh(
                new THREE.SphereGeometry(isTreasure ? 0.3 : 0.15),
                new THREE.MeshBasicMaterial({ color: sparkColor })
              );
              spark.position.copy(partWorldPos);
              scene.add(spark);
              
              const sparkVel = new THREE.Vector3(
                (Math.random() - 0.5) * (isTreasure ? 15 : 8),
                Math.random() * (isTreasure ? 12 : 6),
                (Math.random() - 0.5) * (isTreasure ? 15 : 8)
              );
              spark.userData.vel = sparkVel;
              spark.userData.life = 0;
              
              const sparkTimer = setInterval(() => {
                spark.position.add(spark.userData.vel.clone().multiplyScalar(0.05));
                spark.userData.vel.y -= 0.4;
                spark.userData.life++;
                if (spark.userData.life > 18) {
                  scene.remove(spark);
                  clearInterval(sparkTimer);
                }
              }, 50);
            }

            // Remove cave part
            const parentCave = part.userData.parentCave;
            if (parentCave) {
              parentCave.remove(part);
            }
            caveParts.splice(c, 1);
            
            // Remove bullet
            scene.remove(bullet);
            bullets.splice(i, 1);

            // More points for treasure!
            const points = isTreasure ? 5 : 1;
            score += points;
            scoreDisplay.textContent = score;
            
            // Custom popup for treasure
            const popup = document.createElement('div');
            popup.className = 'score-popup';
            popup.textContent = isTreasure ? 'TREASURE! +5' : 'Score +1!';
            popup.style.color = isTreasure ? '#ffd700' : '#ffff00';
            const pos = partWorldPos.clone().project(camera);
            popup.style.left = ((pos.x * 0.5 + 0.5) * window.innerWidth) + 'px';
            popup.style.top = ((-pos.y * 0.5 + 0.5) * window.innerHeight) + 'px';
            document.body.appendChild(popup);
            setTimeout(() => popup.remove(), 2000);
            
            break;
          }
        }

        // Remove bullets that fly too far
        if (bullet.position.length() > 200) {
          scene.remove(bullet);
          bullets.splice(i, 1);
        }
      }

      renderer.render(scene, camera);
    }
    animate();

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>