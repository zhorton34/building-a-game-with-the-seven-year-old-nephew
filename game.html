<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Jax's Minecraft - Build Anything! üéÆ</title>
  <style>
    body { margin:0; overflow:hidden; font-family: Comic Sans MS, cursive; }
    #info {
      position: absolute; top: 10px; left: 10px; color: white;
      background: rgba(0,0,0,0.5); padding: 10px; border-radius: 10px;
      font-size: 20px;
    }
    #crosshair { position: absolute; top: 50%; left: 50%; font-size: 30px; color: white;
      transform: translate(-50%, -50%); pointer-events: none; }
    .score-popup {
      position: absolute;
      font-size: 48px;
      font-weight: bold;
      color: #ffff00;
      text-shadow: 3px 3px 0 #ff8800, -2px -2px 0 #000;
      pointer-events: none;
      animation: floatUp 2s ease-out forwards;
      z-index: 1000;
    }
    @keyframes floatUp {
      0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
      50% { opacity: 1; transform: translate(-50%, -150%) scale(1.2); }
      100% { opacity: 0; transform: translate(-50%, -250%) scale(0.8); }
    }
    /* Pause Menu Styles */
    #pauseMenu {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      z-index: 2000;
      justify-content: center;
      align-items: center;
    }
    #pauseMenu.active { display: flex; }
    .menu-box {
      background: linear-gradient(180deg, #4a4a4a 0%, #2d2d2d 100%);
      border: 4px solid #6b6b6b;
      border-radius: 0;
      padding: 30px 50px;
      min-width: 350px;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 8px 8px 0 rgba(0,0,0,0.5);
      image-rendering: pixelated;
      /* Minecraft-style scrollbar */
      scrollbar-width: thin;
      scrollbar-color: #888 #333;
    }
    .menu-box::-webkit-scrollbar { width: 12px; }
    .menu-box::-webkit-scrollbar-track { background: #333; border: 2px solid #555; }
    .menu-box::-webkit-scrollbar-thumb { 
      background: linear-gradient(180deg, #888 0%, #666 100%); 
      border: 2px solid #999; 
    }
    .menu-box::-webkit-scrollbar-thumb:hover { 
      background: linear-gradient(180deg, #aaa 0%, #888 100%); 
    }
    /* Break Reminder Overlay */
    #breakReminder {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(30, 100, 180, 0.95);
      z-index: 3000;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      font-family: 'Comic Sans MS', cursive;
    }
    #breakReminder.active { display: flex; }
    .break-box {
      background: linear-gradient(180deg, #4488cc 0%, #2266aa 100%);
      border: 6px solid #88ccff;
      border-radius: 20px;
      padding: 40px 60px;
      text-align: center;
      box-shadow: 0 0 60px rgba(100, 200, 255, 0.5);
      animation: breakPulse 2s ease-in-out infinite;
    }
    @keyframes breakPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.02); }
    }
    .break-emoji { font-size: 80px; margin-bottom: 20px; animation: wave 1s ease-in-out infinite; }
    @keyframes wave {
      0%, 100% { transform: rotate(-10deg); }
      50% { transform: rotate(10deg); }
    }
    .break-title { font-size: 36px; color: #fff; margin-bottom: 15px; text-shadow: 3px 3px 0 #004488; }
    .break-message { font-size: 22px; color: #cceeFF; margin-bottom: 30px; line-height: 1.6; }
    .break-time { font-size: 18px; color: #88ccff; margin-bottom: 25px; }
    .break-btn {
      background: linear-gradient(180deg, #44cc44 0%, #22aa22 100%);
      border: 4px solid #66ff66;
      color: #fff;
      font-size: 24px;
      padding: 15px 40px;
      cursor: pointer;
      font-family: 'Comic Sans MS', cursive;
      text-shadow: 2px 2px 0 #006600;
      transition: transform 0.1s;
    }
    .break-btn:hover { transform: scale(1.05); background: linear-gradient(180deg, #55dd55 0%, #33bb33 100%); }
    /* Tutorial/Welcome Screen */
    #tutorialScreen {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      z-index: 4000;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      font-family: 'Comic Sans MS', cursive;
    }
    #tutorialScreen.active { display: flex; }
    .tutorial-box {
      background: rgba(0, 0, 0, 0.7);
      border: 6px solid #e94560;
      border-radius: 20px;
      padding: 40px 60px;
      max-width: 600px;
      text-align: center;
      animation: tutorialPop 0.5s ease-out;
    }
    @keyframes tutorialPop {
      from { transform: scale(0.8); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }
    .tutorial-title { font-size: 42px; color: #e94560; margin-bottom: 20px; text-shadow: 3px 3px 0 #000; }
    .tutorial-welcome { font-size: 26px; color: #fff; margin-bottom: 30px; }
    .tutorial-controls { 
      text-align: left; 
      background: rgba(255,255,255,0.1); 
      padding: 20px; 
      border-radius: 10px;
      margin-bottom: 25px;
    }
    .tutorial-control { 
      color: #88ccff; 
      font-size: 18px; 
      margin: 12px 0;
      display: flex;
      align-items: center;
    }
    .tutorial-key {
      display: inline-block;
      background: #333;
      border: 2px solid #666;
      padding: 5px 12px;
      margin-right: 15px;
      border-radius: 5px;
      min-width: 80px;
      text-align: center;
      color: #fff;
    }
    .tutorial-tip { font-size: 18px; color: #ffdd00; margin-bottom: 25px; }
    .tutorial-btn {
      background: linear-gradient(180deg, #e94560 0%, #b83449 100%);
      border: 4px solid #ff6b81;
      color: #fff;
      font-size: 28px;
      padding: 18px 50px;
      cursor: pointer;
      font-family: 'Comic Sans MS', cursive;
      text-shadow: 2px 2px 0 #660022;
      transition: transform 0.1s;
      animation: tutorialBtnPulse 1.5s infinite;
    }
    @keyframes tutorialBtnPulse {
      0%, 100% { box-shadow: 0 0 20px rgba(233, 69, 96, 0.5); }
      50% { box-shadow: 0 0 40px rgba(233, 69, 96, 0.8); }
    }
    .tutorial-btn:hover { transform: scale(1.05); }
    .menu-title {
      font-size: 32px;
      color: #fff;
      text-align: center;
      margin-bottom: 25px;
      text-shadow: 3px 3px 0 #000;
      letter-spacing: 2px;
    }
    .menu-setting {
      margin: 20px 0;
      color: #ddd;
      font-size: 18px;
    }
    .menu-setting label {
      display: block;
      margin-bottom: 8px;
    }
    .menu-setting input[type="range"] {
      width: 100%;
      height: 20px;
      -webkit-appearance: none;
      background: #555;
      border: 2px solid #888;
    }
    .menu-setting input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 30px;
      background: #8b8b8b;
      border: 2px solid #aaa;
      cursor: pointer;
    }
    .menu-btn {
      display: block;
      width: 100%;
      padding: 15px;
      margin: 10px 0;
      font-size: 20px;
      font-family: Comic Sans MS, cursive;
      background: linear-gradient(180deg, #5a5a5a 0%, #3a3a3a 100%);
      border: 3px solid #777;
      color: white;
      cursor: pointer;
      text-shadow: 2px 2px 0 #000;
    }
    .menu-btn:hover {
      background: linear-gradient(180deg, #7a7a7a 0%, #5a5a5a 100%);
      border-color: #999;
    }
    .setting-value {
      float: right;
      color: #ffff00;
    }
    /* ===== HEALTH & HUNGER BARS ===== */
    #status-bars {
      position: fixed;
      bottom: 85px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      z-index: 100;
    }
    .status-bar {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .status-bar-label {
      font-size: 20px;
    }
    .status-bar-container {
      width: 200px;
      height: 20px;
      background: #333;
      border: 2px solid #555;
      display: flex;
    }
    .heart, .hunger-icon {
      width: 18px;
      height: 18px;
      margin: 1px;
      transition: opacity 0.3s;
    }
    .heart { background: #ff0000; clip-path: path('M9 2C5 -1 0 3 0 7c0 6 9 11 9 11s9-5 9-11c0-4-5-8-9-5z'); }
    .heart.empty { background: #333; }
    .heart.half { background: linear-gradient(90deg, #ff0000 50%, #333 50%); }
    .hunger-icon { background: #8B4513; border-radius: 50%; }
    .hunger-icon.empty { background: #333; }
    .hunger-icon.half { background: linear-gradient(90deg, #8B4513 50%, #333 50%); }
    /* ===== CRAFTING MENU ===== */
    #craftingMenu {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      z-index: 2000;
      justify-content: center;
      align-items: center;
    }
    #craftingMenu.active { display: flex; }
    .crafting-box {
      background: linear-gradient(180deg, #4a4a4a 0%, #2d2d2d 100%);
      border: 4px solid #6b6b6b;
      padding: 30px;
      min-width: 400px;
    }
    .crafting-title {
      font-size: 28px;
      color: #fff;
      text-align: center;
      margin-bottom: 20px;
      text-shadow: 3px 3px 0 #000;
    }
    .recipe-list {
      max-height: 400px;
      overflow-y: auto;
    }
    .recipe-item {
      background: #3a3a3a;
      border: 2px solid #555;
      padding: 15px;
      margin: 10px 0;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .recipe-item:hover { background: #4a4a4a; border-color: #777; }
    .recipe-item.can-craft { border-color: #4a4; }
    .recipe-item.cannot-craft { opacity: 0.5; }
    .recipe-ingredients { color: #aaa; font-size: 14px; }
    .recipe-result { color: #ffff00; font-size: 18px; }
    /* ===== FURNACE MENU ===== */
    #furnaceMenu {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      z-index: 2000;
      justify-content: center;
      align-items: center;
    }
    #furnaceMenu.active { display: flex; }
    .furnace-box {
      background: linear-gradient(180deg, #555 0%, #333 100%);
      border: 4px solid #777;
      padding: 30px;
      min-width: 400px;
    }
    .furnace-title {
      font-size: 28px;
      color: #fff;
      text-align: center;
      margin-bottom: 20px;
      text-shadow: 2px 2px 0 #000;
    }
    .furnace-slots {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      margin: 20px 0;
    }
    .furnace-slot {
      width: 60px;
      height: 60px;
      background: #222;
      border: 3px solid #555;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 32px;
      cursor: pointer;
      position: relative;
    }
    .furnace-slot:hover { border-color: #888; }
    .furnace-slot.has-item { background: #333; }
    .furnace-arrow {
      font-size: 40px;
      color: #666;
    }
    .furnace-arrow.active { color: #ff8800; }
    .furnace-progress {
      width: 60px;
      height: 10px;
      background: #222;
      border: 2px solid #555;
      margin-top: 10px;
    }
    .furnace-progress-fill {
      height: 100%;
      background: #ff8800;
      width: 0%;
      transition: width 0.1s;
    }
    .furnace-fuel-bar {
      width: 60px;
      height: 10px;
      background: #222;
      border: 2px solid #555;
      margin-top: 5px;
    }
    .furnace-fuel-fill {
      height: 100%;
      background: #ff4400;
      width: 0%;
    }
    .slot-label {
      position: absolute;
      top: -20px;
      font-size: 12px;
      color: #aaa;
    }
    /* ===== DAMAGE OVERLAY ===== */
    #damageOverlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(255, 0, 0, 0);
      pointer-events: none;
      z-index: 500;
      transition: background 0.1s;
    }
    /* ===== DEATH SCREEN ===== */
    #deathScreen {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(100, 0, 0, 0.7);
      z-index: 3000;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      text-align: center;
    }
    #deathScreen.active { display: flex; }
    .death-title {
      font-size: 72px;
      color: #ff0000;
      text-shadow: 4px 4px 0 #400000, -2px -2px 0 #000;
      margin-bottom: 20px;
      animation: deathPulse 2s ease-in-out infinite;
    }
    @keyframes deathPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    .death-message {
      font-size: 28px;
      color: #ffaaaa;
      margin-bottom: 30px;
      text-shadow: 2px 2px 0 #000;
    }
    .death-score {
      font-size: 24px;
      color: #ffff00;
      margin-bottom: 40px;
      text-shadow: 2px 2px 0 #000;
    }
    .death-btn {
      padding: 20px 50px;
      font-size: 24px;
      font-family: Comic Sans MS, cursive;
      background: linear-gradient(180deg, #5a5a5a 0%, #3a3a3a 100%);
      border: 4px solid #777;
      color: white;
      cursor: pointer;
      text-shadow: 2px 2px 0 #000;
      margin: 10px;
      transition: all 0.2s;
    }
    .death-btn:hover {
      background: linear-gradient(180deg, #7a7a7a 0%, #5a5a5a 100%);
      border-color: #999;
      transform: scale(1.05);
    }
    /* ===== BLOCK DAMAGE INDICATOR ===== */
    .damage-crack {
      position: absolute;
      font-size: 60px;
      color: rgba(0,0,0,0.5);
      pointer-events: none;
      z-index: 100;
    }
    /* ===== INVENTORY HOTBAR ===== */
    #hotbar {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 4px;
      z-index: 100;
    }
    .hotbar-slot {
      width: 50px;
      height: 50px;
      background: rgba(50, 50, 50, 0.8);
      border: 3px solid #555;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      image-rendering: pixelated;
    }
    .hotbar-slot.selected {
      border-color: #fff;
      background: rgba(80, 80, 80, 0.9);
      box-shadow: 0 0 10px rgba(255,255,255,0.5);
    }
    .hotbar-slot .slot-num {
      position: absolute;
      top: 2px;
      left: 4px;
      font-size: 10px;
      color: #aaa;
    }
    .hotbar-slot .item-icon {
      width: 30px;
      height: 30px;
      margin-top: 5px;
    }
    .hotbar-slot .item-count {
      position: absolute;
      bottom: 2px;
      right: 4px;
      font-size: 12px;
      color: #fff;
      text-shadow: 1px 1px 0 #000;
    }
  </style>
</head>
<body>
  <div id="info">Arrows = Move ‚Ä¢ WASD/Mouse = Aim ‚Ä¢ Z = Mine ‚Ä¢ Right-Click = Shoot ‚Ä¢ X = Place ‚Ä¢ F = Eat ‚Ä¢ C = Craft ‚Ä¢ R = Furnace ‚Ä¢ Esc = Menu<br>Score: <span id="score">0</span> üéØ</div>
  <div id="crosshair">+</div>
  <div id="damageOverlay"></div>
  
  <!-- Death Screen -->
  <div id="deathScreen">
    <div class="death-title">‚ò†Ô∏è YOU DIED! ‚ò†Ô∏è</div>
    <div class="death-message" id="deathMessage">You died</div>
    <div class="death-score">Score: <span id="deathScore">0</span></div>
    <button class="death-btn" id="respawnBtn">üîÑ RESPAWN</button>
  </div>
  
  <!-- Tutorial/Welcome Screen -->
  <div id="tutorialScreen">
    <div class="tutorial-box">
      <div class="tutorial-title">üéÆ JAX'S MINECRAFT üéÆ</div>
      <div class="tutorial-welcome">Welcome, Adventurer! üåü</div>
      <div class="tutorial-controls">
        <div class="tutorial-control"><span class="tutorial-key">‚Üë ‚Üì ‚Üê ‚Üí</span> Move around</div>
        <div class="tutorial-control"><span class="tutorial-key">WASD</span> Look around</div>
        <div class="tutorial-control"><span class="tutorial-key">Z / Click</span> Mine blocks</div>
        <div class="tutorial-control"><span class="tutorial-key">X</span> Place blocks</div>
        <div class="tutorial-control"><span class="tutorial-key">C</span> Open crafting</div>
        <div class="tutorial-control"><span class="tutorial-key">R</span> Open furnace</div>
        <div class="tutorial-control"><span class="tutorial-key">F</span> Eat food</div>
        <div class="tutorial-control"><span class="tutorial-key">Right Click</span> Shoot! üî´</div>
      </div>
      <div class="tutorial-tip">üí° Tip: Mine trees üå≤ to get wood, then craft tools!</div>
      <button class="tutorial-btn" id="startGameBtn">üöÄ START PLAYING!</button>
    </div>
  </div>
  
  <!-- Break Reminder -->
  <div id="breakReminder">
    <div class="break-box">
      <div class="break-emoji">üßò</div>
      <div class="break-title">Time for a Break!</div>
      <div class="break-message">
        You've been playing for a while!<br>
        Stand up, stretch, and rest your eyes! üëÄ<br>
        Maybe get some water or a snack! ü•§
      </div>
      <div class="break-time" id="playTimeDisplay">Play time: 30 minutes</div>
      <button class="break-btn" id="breakOkBtn">‚úÖ I stretched! Let's play!</button>
    </div>
  </div>

  <!-- Health & Hunger Bars -->
  <div id="status-bars">
    <div class="status-bar">
      <span class="status-bar-label">‚ù§Ô∏è</span>
      <div class="status-bar-container" id="health-bar"></div>
    </div>
    <div class="status-bar">
      <span class="status-bar-label">üçñ</span>
      <div class="status-bar-container" id="hunger-bar"></div>
    </div>
  </div>

  <!-- Crafting Menu -->
  <div id="craftingMenu">
    <div class="crafting-box">
      <div class="crafting-title">‚öíÔ∏è CRAFTING ‚öíÔ∏è</div>
      <div class="recipe-list" id="recipeList"></div>
      <button class="menu-btn" id="closeCraftingBtn">‚ùå CLOSE (C)</button>
    </div>
  </div>
  
  <!-- Furnace Menu -->
  <div id="furnaceMenu">
    <div class="furnace-box">
      <div class="furnace-title">üî• FURNACE üî•</div>
      <div class="furnace-slots">
        <div>
          <div class="furnace-slot" id="furnaceInput"><span class="slot-label">INPUT</span></div>
        </div>
        <div class="furnace-arrow" id="furnaceArrow">‚Üí</div>
        <div>
          <div class="furnace-slot" id="furnaceOutput"><span class="slot-label">OUTPUT</span></div>
        </div>
      </div>
      <div style="text-align: center;">
        <div class="furnace-progress"><div class="furnace-progress-fill" id="smeltProgress"></div></div>
      </div>
      <div class="furnace-slots" style="margin-top: 20px;">
        <div>
          <div class="furnace-slot" id="furnaceFuel"><span class="slot-label">FUEL</span></div>
          <div class="furnace-fuel-bar"><div class="furnace-fuel-fill" id="fuelProgress"></div></div>
        </div>
      </div>
      <div style="margin-top: 20px; color: #aaa; font-size: 14px; text-align: center;">
        Click slots to add/remove items from inventory
      </div>
      <button class="menu-btn" id="closeFurnaceBtn">‚ùå CLOSE</button>
    </div>
  </div>

  <!-- Inventory Hotbar -->
  <div id="hotbar">
    <div class="hotbar-slot selected" data-slot="1"><span class="slot-num">1</span></div>
    <div class="hotbar-slot" data-slot="2"><span class="slot-num">2</span></div>
    <div class="hotbar-slot" data-slot="3"><span class="slot-num">3</span></div>
    <div class="hotbar-slot" data-slot="4"><span class="slot-num">4</span></div>
    <div class="hotbar-slot" data-slot="5"><span class="slot-num">5</span></div>
    <div class="hotbar-slot" data-slot="6"><span class="slot-num">6</span></div>
    <div class="hotbar-slot" data-slot="7"><span class="slot-num">7</span></div>
    <div class="hotbar-slot" data-slot="8"><span class="slot-num">8</span></div>
    <div class="hotbar-slot" data-slot="9"><span class="slot-num">9</span></div>
  </div>

  <!-- Pause Menu -->
  <div id="pauseMenu">
    <div class="menu-box">
      <div class="menu-title">‚öôÔ∏è PAUSED ‚öôÔ∏è</div>
      
      <div class="menu-setting">
        <label>Aim Sensitivity <span class="setting-value" id="sensValue">2.0</span></label>
        <input type="range" id="sensitivitySlider" min="0.5" max="5" step="0.1" value="2">
      </div>

      <div class="menu-setting">
        <label>Crosshair Size <span class="setting-value" id="crosshairValue">30</span></label>
        <input type="range" id="crosshairSlider" min="15" max="60" step="1" value="30">
      </div>

      <div class="menu-setting">
        <label>üëÅÔ∏è Field of View <span class="setting-value" id="fovValue">75¬∞</span></label>
        <input type="range" id="fovSlider" min="50" max="110" step="5" value="75">
      </div>

      <div class="menu-setting">
        <label>üí° Brightness <span class="setting-value" id="brightnessValue">100%</span></label>
        <input type="range" id="brightnessSlider" min="50" max="150" step="10" value="100">
      </div>

      <div class="menu-setting" style="border-top: 2px solid #555; padding-top: 15px; margin-top: 15px;">
        <label>üåû Time of Day <span class="setting-value" id="timeValue">12:00</span></label>
        <input type="range" id="timeSlider" min="0" max="1" step="0.01" value="0.5">
      </div>

      <div class="menu-setting">
        <label>‚è±Ô∏è Day Speed <span class="setting-value" id="speedValue">Normal</span></label>
        <input type="range" id="speedSlider" min="0" max="3" step="1" value="1">
      </div>

      <div style="display: flex; gap: 10px; margin-top: 15px;">
        <button class="menu-btn" id="setDayBtn" style="flex: 1;">‚òÄÔ∏è SET DAY</button>
        <button class="menu-btn" id="setNightBtn" style="flex: 1;">üåô SET NIGHT</button>
      </div>

      <div class="menu-setting" style="border-top: 2px solid #555; padding-top: 15px; margin-top: 15px;">
        <label>üîä Master Volume <span class="setting-value" id="masterVolValue">100%</span></label>
        <input type="range" id="masterVolSlider" min="0" max="100" step="5" value="100">
      </div>

      <div class="menu-setting">
        <label>‚õèÔ∏è Blocks Volume <span class="setting-value" id="blocksVolValue">100%</span></label>
        <input type="range" id="blocksVolSlider" min="0" max="100" step="5" value="100">
      </div>

      <div class="menu-setting">
        <label>üë§ Player Volume <span class="setting-value" id="playerVolValue">100%</span></label>
        <input type="range" id="playerVolSlider" min="0" max="100" step="5" value="100">
      </div>

      <div class="menu-setting">
        <label>üê∑ Mobs Volume <span class="setting-value" id="mobsVolValue">100%</span></label>
        <input type="range" id="mobsVolSlider" min="0" max="100" step="5" value="100">
      </div>

      <div class="menu-setting">
        <label>üñ±Ô∏è UI Volume <span class="setting-value" id="uiVolValue">100%</span></label>
        <input type="range" id="uiVolSlider" min="0" max="100" step="5" value="100">
      </div>
      
      <div style="border-top: 2px solid #555; margin: 20px 0; padding-top: 15px;">
        <div style="display: flex; gap: 10px; margin-bottom: 10px;">
          <button class="menu-btn" id="saveBtn" style="flex: 1;">üíæ SAVE</button>
          <button class="menu-btn" id="loadBtn" style="flex: 1;">üìÇ LOAD</button>
        </div>
      </div>

      <button class="menu-btn" id="resumeBtn">‚ñ∂Ô∏è RESUME</button>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.168.0';
    import { PointerLockControls } from 'https://esm.sh/three@0.168.0/examples/jsm/controls/PointerLockControls.js';

    // ===== SOUND SYSTEM (Synthesized Web Audio API) =====
    class SoundSystem {
      constructor() {
        this.context = null;
        this.masterGain = null;
        this.categories = {};
        this.initialized = false;
      }
      
      // Must be called after user interaction (browser requirement)
      init() {
        if (this.initialized) return;
        
        try {
          this.context = new (window.AudioContext || window.webkitAudioContext)();
          this.masterGain = this.context.createGain();
          this.masterGain.connect(this.context.destination);
          
          // Create category gain nodes
          this.categories = {
            master: { gain: this.masterGain, volume: 1.0 },
            blocks: this.createCategory(1.0),
            player: this.createCategory(1.0),
            mobs: this.createCategory(1.0),
            ui: this.createCategory(1.0),
          };
          
          this.initialized = true;
          console.log('üîä Sound system initialized!');
        } catch (e) {
          console.warn('Could not initialize audio:', e);
        }
      }
      
      createCategory(defaultVolume) {
        const gain = this.context.createGain();
        gain.gain.value = defaultVolume;
        gain.connect(this.masterGain);
        return { gain, volume: defaultVolume };
      }
      
      setVolume(category, value) {
        if (!this.initialized) return;
        const vol = value / 100;
        if (category === 'master') {
          this.masterGain.gain.value = vol;
        } else if (this.categories[category]) {
          this.categories[category].gain.gain.value = vol;
          this.categories[category].volume = vol;
        }
      }
      
      // Play a synthesized tone
      playTone(frequencies, duration, type = 'sine', category = 'master', volume = 0.3) {
        if (!this.initialized) return;
        
        const osc = this.context.createOscillator();
        osc.type = type;
        
        // Frequency sweep for interesting sounds
        if (Array.isArray(frequencies)) {
          osc.frequency.setValueAtTime(frequencies[0], this.context.currentTime);
          osc.frequency.linearRampToValueAtTime(frequencies[1], this.context.currentTime + duration);
        } else {
          osc.frequency.setValueAtTime(frequencies, this.context.currentTime);
        }
        
        const gainNode = this.context.createGain();
        gainNode.gain.setValueAtTime(volume, this.context.currentTime);
        gainNode.gain.linearRampToValueAtTime(0, this.context.currentTime + duration);
        
        osc.connect(gainNode);
        const targetGain = category === 'master' ? this.masterGain : this.categories[category]?.gain || this.masterGain;
        gainNode.connect(targetGain);
        
        osc.start();
        osc.stop(this.context.currentTime + duration);
      }
      
      // Play noise (for impacts, explosions, etc.)
      playNoise(duration, filterType = 'lowpass', filterFreq = 1000, category = 'master', volume = 0.3) {
        if (!this.initialized) return;
        
        const bufferSize = this.context.sampleRate * duration;
        const buffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < bufferSize; i++) {
          data[i] = Math.random() * 2 - 1;
        }
        
        const noise = this.context.createBufferSource();
        noise.buffer = buffer;
        
        const filter = this.context.createBiquadFilter();
        filter.type = filterType;
        filter.frequency.value = filterFreq;
        
        const gainNode = this.context.createGain();
        gainNode.gain.setValueAtTime(volume, this.context.currentTime);
        gainNode.gain.linearRampToValueAtTime(0, this.context.currentTime + duration);
        
        noise.connect(filter);
        filter.connect(gainNode);
        const targetGain = category === 'master' ? this.masterGain : this.categories[category]?.gain || this.masterGain;
        gainNode.connect(targetGain);
        
        noise.start();
      }
      
      // ===== PREDEFINED SOUNDS =====
      
      // Block sounds
      digStone() { this.playNoise(0.08, 'highpass', 2000, 'blocks', 0.2); }
      digDirt() { this.playNoise(0.1, 'lowpass', 800, 'blocks', 0.25); }
      digWood() { this.playTone([200, 150], 0.1, 'square', 'blocks', 0.15); }
      
      // Satisfying block place "thunk"
      placeBlock() { 
        this.playTone([150, 200], 0.06, 'square', 'blocks', 0.25);
        this.playNoise(0.04, 'lowpass', 600, 'blocks', 0.15);
      }
      
      // Epic block break with shatter sound!
      breakBlock() { 
        this.playNoise(0.2, 'highpass', 1200, 'blocks', 0.35);
        this.playTone([500, 200, 80], 0.15, 'sawtooth', 'blocks', 0.2);
        this.playNoise(0.1, 'bandpass', 3000, 'blocks', 0.15); // Glass-like shatter
      }
      
      // Mining hit - varies pitch for interest!
      mineHit() { 
        const pitch = 200 + Math.random() * 200; // Random pitch variation
        this.playNoise(0.05, 'bandpass', 1500 + Math.random() * 1000, 'blocks', 0.2); 
        this.playTone([pitch, pitch * 0.6], 0.04, 'square', 'blocks', 0.12);
      }
      
      // Metal/stone scrape sound for pickaxe
      pickaxeHit() {
        this.playTone([800, 400, 200], 0.08, 'sawtooth', 'blocks', 0.15);
        this.playNoise(0.04, 'highpass', 3000, 'blocks', 0.2);
      }
      
      // Cool ricochet "bonk" - distance-based volume!
      ricochet(distance = 0) {
        // Calculate volume based on distance (quieter when farther away)
        const maxDist = 50;
        const distFactor = Math.max(0, 1 - (distance / maxDist));
        const volume = 0.35 * distFactor;
        
        if (volume < 0.02) return; // Too quiet to hear
        
        // Lower, more satisfying "thunk/bonk" sound
        const pitch = 300 + Math.random() * 200; // Lower base pitch (300-500 Hz)
        this.playTone([pitch, pitch * 0.5], 0.1, 'square', 'blocks', volume);
        this.playNoise(0.05, 'bandpass', 800, 'blocks', volume * 0.5);
      }
      
      // Extra satisfying explosion for block destruction
      explosion() {
        this.playNoise(0.25, 'lowpass', 200, 'blocks', 0.5);
        this.playTone([100, 40], 0.2, 'sine', 'blocks', 0.35);
        this.playNoise(0.1, 'bandpass', 800, 'blocks', 0.2); // Debris scatter
      }
      
      // Player sounds
      hurt() { 
        this.playTone([400, 200], 0.15, 'sawtooth', 'player', 0.3);
        this.playNoise(0.1, 'lowpass', 500, 'player', 0.2);
      }
      
      death() {
        this.playTone([300, 80], 0.4, 'sawtooth', 'player', 0.4);
        this.playNoise(0.3, 'lowpass', 300, 'player', 0.3);
      }
      
      jump() { this.playTone([150, 250], 0.1, 'sine', 'player', 0.15); }
      land() { this.playNoise(0.08, 'lowpass', 400, 'player', 0.2); }
      landHard() { 
        this.playNoise(0.15, 'lowpass', 300, 'player', 0.4);
        this.playTone([100, 50], 0.1, 'sine', 'player', 0.2);
      }
      
      eat() { 
        this.playNoise(0.08, 'bandpass', 1000, 'player', 0.2);
        setTimeout(() => this.playNoise(0.08, 'bandpass', 1200, 'player', 0.2), 100);
      }
      
      burp() { this.playTone([150, 80], 0.2, 'sawtooth', 'player', 0.15); }
      
      footstep() { this.playNoise(0.04, 'lowpass', 600, 'player', 0.1); }
      
      // Item sounds
      itemPickup() { this.playTone([600, 900], 0.1, 'sine', 'player', 0.25); }
      
      // Shooting
      shoot() { 
        this.playTone([800, 200], 0.1, 'sawtooth', 'player', 0.2);
        this.playNoise(0.05, 'highpass', 2000, 'player', 0.15);
      }
      
      // Bullet flyby "whoosh" sound
      playFlyby() {
        // Quick whoosh sound - filtered noise with pitch sweep
        this.playNoise(0.15, 'bandpass', 1500, 'player', 0.3);
        this.playTone([2000, 500], 0.1, 'sine', 'player', 0.1);
      }
      
      // Ricochet hit sound (when bullet hits player)
      ricochetHit() {
        this.playTone([300, 100], 0.1, 'sawtooth', 'player', 0.3);
        this.playNoise(0.08, 'lowpass', 500, 'player', 0.2);
      }
      
      // UI sounds
      menuOpen() { this.playTone([400, 600], 0.1, 'sine', 'ui', 0.2); }
      menuClose() { this.playTone([600, 400], 0.1, 'sine', 'ui', 0.2); }
      buttonClick() { this.playTone([800, 600], 0.05, 'square', 'ui', 0.15); }
      craftSuccess() { this.playTone([500, 700, 900], 0.15, 'sine', 'ui', 0.25); }
      error() { this.playTone([200, 150], 0.15, 'square', 'ui', 0.2); }
      
      // Level up / XP
      levelUp() {
        this.playTone([400, 600], 0.1, 'sine', 'player', 0.3);
        setTimeout(() => this.playTone([600, 800], 0.1, 'sine', 'player', 0.3), 100);
        setTimeout(() => this.playTone([800, 1000], 0.15, 'sine', 'player', 0.3), 200);
      }
      
      xpOrb() { this.playTone([800 + Math.random() * 400, 1200], 0.08, 'sine', 'player', 0.15); }
      
      // Mob sounds (basic versions - will be expanded in mob section)
      mobHurt() { this.playTone([300, 150], 0.12, 'sawtooth', 'mobs', 0.25); }
      mobDeath() { this.playTone([250, 80], 0.3, 'sawtooth', 'mobs', 0.3); }
      
      pigOink() { 
        const pitch = 200 + Math.random() * 100;
        this.playTone([pitch, pitch * 0.8], 0.15, 'sawtooth', 'mobs', 0.2);
      }
      
      cowMoo() {
        this.playTone([120, 100], 0.4, 'sawtooth', 'mobs', 0.25);
      }
      
      chickenCluck() {
        const pitch = 400 + Math.random() * 100;
        this.playTone([pitch, pitch * 1.2], 0.08, 'square', 'mobs', 0.15);
      }
      
      sheepBaa() {
        this.playTone([250, 200], 0.3, 'sawtooth', 'mobs', 0.2);
      }
      
      zombieGroan() {
        this.playTone([100, 80], 0.4, 'sawtooth', 'mobs', 0.3);
        this.playNoise(0.2, 'lowpass', 200, 'mobs', 0.15);
      }
      
      skeletonRattle() {
        this.playNoise(0.1, 'highpass', 3000, 'mobs', 0.2);
        setTimeout(() => this.playNoise(0.08, 'highpass', 3500, 'mobs', 0.15), 50);
      }
      
      spiderHiss() {
        this.playNoise(0.2, 'bandpass', 2000, 'mobs', 0.25);
      }
      
      creeperFuse() {
        this.playNoise(0.1, 'highpass', 4000, 'mobs', 0.3);
      }
    }
    
    // Global sound system instance
    const soundSystem = new SoundSystem();
    // ===== END SOUND SYSTEM =====

    // ===== TEST MODE (for browser automation) =====
    // Activate with URL parameter: ?testMode=true
    const urlParams = new URLSearchParams(window.location.search);
    const TEST_MODE = urlParams.get('testMode') === 'true';
    if (TEST_MODE) {
      console.log('üß™ TEST MODE ACTIVE - Pointer Lock disabled, keyboard controls enabled');
    }
    
    // Test mode camera rotation state
    const testModeCamera = {
      yaw: 0,   // Left/right rotation
      pitch: 0, // Up/down rotation
      rotateLeft: false,
      rotateRight: false,
      rotateUp: false,
      rotateDown: false,
      sensitivity: 0.03
    };

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb); // sky blue
    // Stronger fog that blends with sky - makes world feel INFINITE!
    scene.fog = new THREE.Fog(0x87ceeb, 50, 200); // Linear fog: starts at 50, fully opaque at 200

    const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 500);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Lock pointer when clicked (but not when paused or clicking menu)
    const controls = new PointerLockControls(camera, document.body);
    document.body.addEventListener('click', (e) => {
      if (TEST_MODE) {
        // In test mode, don't lock pointer - just initialize sound
        soundSystem.init();
        return;
      }
      if (!isPaused && !e.target.closest('#pauseMenu')) {
        // Initialize sound system on first interaction (browser requirement)
        soundSystem.init();
        controls.lock();
      }
    });

    // Invisible ground plane - only used for raycast detection, not rendered
    // Actual terrain is made of grass/dirt/stone blocks like Minecraft!
    const groundGeo = new THREE.PlaneGeometry(1000, 1000);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x3ab33a, visible: false });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0; // Keep at y=0 for raycast reference
    ground.visible = false; // Hidden - we use actual blocks now!
    scene.add(ground);

    // Track all blocks so we can break them!
    const blocks = [];
    const blockColors = [0xff00ff, 0x00ffff, 0xffff00, 0xff8800, 0x00ff00, 0xff0000, 0x0088ff];
    
    // ===== DIGGABLE GROUND SYSTEM (Minecraft-style!) =====
    // Ground is made of actual blocks: grass on top, dirt below, then stone
    const groundBlocks = [];
    const dugOutPositions = new Set(); // Track positions that have been mined (don't regenerate)
    const GROUND_BLOCK_SIZE = 4;
    const GROUND_DEPTH = 4; // How many layers deep (grass, dirt, dirt, stone)
    
    // Create a ground block (grass/dirt/stone)
    function makeGroundBlock(x, y, z, type = 'grass') {
      const geo = new THREE.BoxGeometry(GROUND_BLOCK_SIZE, GROUND_BLOCK_SIZE, GROUND_BLOCK_SIZE);
      
      // Minecraft-style colors
      let color;
      if (type === 'grass') {
        color = 0x3ab33a; // Green grass top
      } else if (type === 'dirt') {
        color = 0x8B4513; // Brown dirt
      } else {
        color = 0x808080; // Gray stone
      }
      
      const mat = new THREE.MeshStandardMaterial({ color });
      const block = new THREE.Mesh(geo, mat);
      block.position.set(x, y, z);
      block.castShadow = true;
      block.receiveShadow = true;
      block.userData.type = type;
      block.userData.isGroundBlock = true;
      scene.add(block);
      groundBlocks.push(block);
      return block;
    }
    
    // Generate ground blocks around a position (Minecraft-style terrain!)
    // Creates blocks on-demand for infinite world feel
    function ensureGroundBlocksNear(x, z) {
      const gridX = Math.round(x / GROUND_BLOCK_SIZE) * GROUND_BLOCK_SIZE;
      const gridZ = Math.round(z / GROUND_BLOCK_SIZE) * GROUND_BLOCK_SIZE;
      
      // Generate blocks at this position and neighbors
      const positions = [
        [gridX, gridZ],
        [gridX + GROUND_BLOCK_SIZE, gridZ],
        [gridX - GROUND_BLOCK_SIZE, gridZ],
        [gridX, gridZ + GROUND_BLOCK_SIZE],
        [gridX, gridZ - GROUND_BLOCK_SIZE],
        [gridX + GROUND_BLOCK_SIZE, gridZ + GROUND_BLOCK_SIZE],
        [gridX - GROUND_BLOCK_SIZE, gridZ + GROUND_BLOCK_SIZE],
        [gridX + GROUND_BLOCK_SIZE, gridZ - GROUND_BLOCK_SIZE],
        [gridX - GROUND_BLOCK_SIZE, gridZ - GROUND_BLOCK_SIZE],
      ];
      
      for (const [px, pz] of positions) {
        for (let dy = 0; dy < GROUND_DEPTH; dy++) {
          // Blocks at y=2 (grass), y=-2 (dirt), y=-6 (dirt), y=-10 (stone)
          // Block at y=2 has top at y=4, matching player eye height of 5 when standing
          const blockY = 2 - (dy * GROUND_BLOCK_SIZE);
          
          // Check if block already exists at this position
          let exists = false;
          for (const gb of groundBlocks) {
            if (Math.abs(gb.position.x - px) < 1 && 
                Math.abs(gb.position.y - blockY) < 1 && 
                Math.abs(gb.position.z - pz) < 1) {
              exists = true;
              break;
            }
          }
          
          if (!exists) {
            // Check if this position was dug out by player (don't regenerate)
            const posKey = `${px},${blockY},${pz}`;
            if (dugOutPositions.has(posKey)) {
              continue; // Player mined this block, don't regenerate
            }
            
            // Grass on top, then dirt, then stone deeper down
            let type;
            if (dy === 0) {
              type = 'grass';
            } else if (dy < 3) {
              type = 'dirt';
            } else {
              type = 'stone';
            }
            makeGroundBlock(px, blockY, pz, type);
          }
        }
      }
    }
    // ===== END DIGGABLE GROUND =====

    // Some colorful building blocks (easy to copy-paste more!)
    // Now supports Y position for vertical stacking!
    // Default y=6 puts block center there (bottom at y=4 = top of grass blocks)
    function makeBlock(x, z, color = 0xff0000, y = 6) {
      const geo = new THREE.BoxGeometry(4, 4, 4);
      const mat = new THREE.MeshStandardMaterial({ color });
      const block = new THREE.Mesh(geo, mat);
      block.position.set(x, y, z);
      block.castShadow = true;
      block.receiveShadow = true;
      scene.add(block);
      blocks.push(block); // Remember this block!
      return block;
    }

    // Spawn a new block at random spot
    function spawnRandomBlock() {
      const x = (Math.random() - 0.5) * 80;
      const z = -10 - Math.random() * 60;
      const color = blockColors[Math.floor(Math.random() * blockColors.length)];
      makeBlock(x, z, color);
    }

    makeBlock(10, -10, 0xff00ff);
    makeBlock(-10, -15, 0x00ffff);
    makeBlock(0, -20, 0xffff00);
    makeBlock(15, -25, 0xff8800);

    // ===== PHASE 1: MINECRAFT-STYLE TREES =====
    // Trees are groups of blocks (trunk + leaves) that can be destroyed
    const trees = []; // Track all trees for collision/destruction
    const treeParts = []; // Individual blocks that make up trees (for shooting)

    /**
     * Creates a Minecraft-style tree at position (x, z)
     * @param {number} x - X position
     * @param {number} z - Z position  
     * @param {number} trunkHeight - Height of trunk (default 3)
     * @returns {THREE.Group} The tree group
     */
    function makeTree(x, z, trunkHeight = 3) {
      const tree = new THREE.Group();
      tree.userData.type = 'tree'; // For identification
      
      // Trunk - brown wooden blocks stacked
      const trunkColor = 0x8B4513; // Saddle brown (wood)
      for (let y = 0; y < trunkHeight; y++) {
        const trunk = new THREE.Mesh(
          new THREE.BoxGeometry(2, 2, 2),
          new THREE.MeshStandardMaterial({ color: trunkColor })
        );
        trunk.position.set(0, 1 + y * 2, 0);
        trunk.castShadow = true;
        trunk.receiveShadow = true;
        trunk.userData.type = 'trunk';
        trunk.userData.parentTree = tree;
        tree.add(trunk);
        treeParts.push(trunk);
      }
      
      // Leaves - green blocks in a cross/cluster pattern on top
      const leafColor = 0x228B22; // Forest green
      const leafY = trunkHeight * 2 + 1; // Top of trunk
      const leafPositions = [
        // Top layer
        [0, leafY + 2, 0],
        // Middle layer (cross pattern)
        [0, leafY, 0],
        [2, leafY, 0], [-2, leafY, 0],
        [0, leafY, 2], [0, leafY, -2],
        // Corner leaves
        [2, leafY, 2], [-2, leafY, 2],
        [2, leafY, -2], [-2, leafY, -2],
      ];
      
      leafPositions.forEach(pos => {
        const leaf = new THREE.Mesh(
          new THREE.BoxGeometry(2, 2, 2),
          new THREE.MeshStandardMaterial({ color: leafColor })
        );
        leaf.position.set(pos[0], pos[1], pos[2]);
        leaf.castShadow = true;
        leaf.receiveShadow = true;
        leaf.userData.type = 'leaf';
        leaf.userData.parentTree = tree;
        tree.add(leaf);
        treeParts.push(leaf);
      });
      
      // Position the whole tree
      tree.position.set(x, 0, z);
      scene.add(tree);
      trees.push(tree);
      
      return tree;
    }

    // Spawn trees around the map (away from player start at 0,0)
    const treePositions = [
      [-30, -20], [35, -25], [-25, -45], [40, -50],
      [-45, -35], [25, -60], [-15, -55], [50, -30],
    ];
    treePositions.forEach(pos => makeTree(pos[0], pos[1]));

    // ===== END PHASE 1 =====

    // ===== PHASE 2: CAVES =====
    // Caves are dark stone structures with entrances
    const caves = [];
    const caveParts = []; // Stone blocks that can be shot

    /**
     * Creates a cave entrance at position (x, z)
     * @param {number} x - X position
     * @param {number} z - Z position
     * @param {number} rotation - Rotation in radians (which way entrance faces)
     */
    function makeCave(x, z, rotation = 0) {
      const cave = new THREE.Group();
      cave.userData.type = 'cave';
      
      const stoneColor = 0x555555; // Dark gray stone
      const stoneDarkColor = 0x333333; // Even darker for depth
      
      // Cave frame - arch-like entrance
      const stonePositions = [
        // Left pillar
        [-3, 1, 0], [-3, 3, 0], [-3, 5, 0],
        // Right pillar  
        [3, 1, 0], [3, 3, 0], [3, 5, 0],
        // Top arch
        [-2, 7, 0], [0, 7, 0], [2, 7, 0],
        [-1, 8, 0], [1, 8, 0], [0, 9, 0],
        // Back wall (darker)
        [-3, 1, -4], [-1, 1, -4], [1, 1, -4], [3, 1, -4],
        [-3, 3, -4], [-1, 3, -4], [1, 3, -4], [3, 3, -4],
        [-2, 5, -4], [0, 5, -4], [2, 5, -4],
        // Side walls
        [-3, 1, -2], [-3, 3, -2], [3, 1, -2], [3, 3, -2],
        // Roof
        [-2, 7, -2], [0, 7, -2], [2, 7, -2],
      ];
      
      stonePositions.forEach((pos, i) => {
        const isBackWall = pos[2] < -2;
        const stone = new THREE.Mesh(
          new THREE.BoxGeometry(2, 2, 2),
          new THREE.MeshStandardMaterial({ 
            color: isBackWall ? stoneDarkColor : stoneColor 
          })
        );
        stone.position.set(pos[0], pos[1], pos[2]);
        stone.castShadow = true;
        stone.receiveShadow = true;
        stone.userData.type = 'stone';
        stone.userData.parentCave = cave;
        cave.add(stone);
        caveParts.push(stone);
      });
      
      // Add a special glowing block inside the cave (treasure!)
      const treasureColors = [0xff00ff, 0x00ffff, 0xffff00, 0xff0000];
      const treasure = new THREE.Mesh(
        new THREE.BoxGeometry(1.5, 1.5, 1.5),
        new THREE.MeshStandardMaterial({ 
          color: treasureColors[Math.floor(Math.random() * treasureColors.length)],
          emissive: 0x222222,
        })
      );
      treasure.position.set(0, 1, -3);
      treasure.userData.type = 'treasure';
      treasure.userData.parentCave = cave;
      cave.add(treasure);
      caveParts.push(treasure);
      
      // Add ore blocks to the cave walls
      const oreTypes = [
        { type: 'coal_ore', color: 0x222222, specks: 0x111111, rarity: 0.4 },
        { type: 'iron_ore', color: 0x555555, specks: 0xD8AF93, rarity: 0.3 },
        { type: 'gold_ore', color: 0x555555, specks: 0xFFD700, rarity: 0.2 },
        { type: 'diamond_ore', color: 0x555555, specks: 0x00FFFF, rarity: 0.1 },
      ];
      
      // Spawn 3-6 ore blocks per cave
      const oreCount = 3 + Math.floor(Math.random() * 4);
      for (let o = 0; o < oreCount; o++) {
        // Pick random ore type based on rarity
        let oreType;
        const roll = Math.random();
        if (roll < 0.1) oreType = oreTypes[3]; // Diamond (10%)
        else if (roll < 0.3) oreType = oreTypes[2]; // Gold (20%)
        else if (roll < 0.6) oreType = oreTypes[1]; // Iron (30%)
        else oreType = oreTypes[0]; // Coal (40%)
        
        // Create ore block with colored specks
        const oreGeo = new THREE.BoxGeometry(1.8, 1.8, 1.8);
        const oreMat = new THREE.MeshStandardMaterial({ 
          color: oreType.color,
        });
        const ore = new THREE.Mesh(oreGeo, oreMat);
        
        // Add specks (small cubes on the surface)
        for (let s = 0; s < 5; s++) {
          const speck = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.3, 0.3),
            new THREE.MeshStandardMaterial({ 
              color: oreType.specks,
              emissive: oreType.type === 'diamond_ore' ? 0x003333 : 0x000000,
            })
          );
          speck.position.set(
            (Math.random() - 0.5) * 1.5,
            (Math.random() - 0.5) * 1.5,
            0.9
          );
          ore.add(speck);
        }
        
        // Position ore in cave walls
        const orePos = [
          [-3, 1 + Math.random() * 4, -2 - Math.random() * 2],
          [3, 1 + Math.random() * 4, -2 - Math.random() * 2],
          [Math.random() * 4 - 2, 5 + Math.random() * 2, -3],
        ][Math.floor(Math.random() * 3)];
        
        ore.position.set(orePos[0], orePos[1], orePos[2]);
        ore.userData.type = oreType.type;
        ore.userData.oreType = oreType.type;
        ore.userData.parentCave = cave;
        cave.add(ore);
        caveParts.push(ore);
      }
      
      // Position and rotate the cave
      cave.position.set(x, 0, z);
      cave.rotation.y = rotation;
      scene.add(cave);
      caves.push(cave);
      
      return cave;
    }

    // Spawn a few caves around the edges of the map
    makeCave(-60, -40, Math.PI * 0.1);  // Left side, facing slightly right
    makeCave(55, -55, Math.PI * 0.8);   // Right side, facing left-ish
    makeCave(0, -75, 0);                // Far back, facing player

    // ===== PRE-GENERATE MINECRAFT-STYLE GROUND =====
    // Generate grass/dirt/stone blocks around spawn area so player has terrain to stand on!
    // This creates a visible floor instead of the old invisible green plane
    const SPAWN_RADIUS = 10; // Generate in a grid around spawn
    for (let gx = -SPAWN_RADIUS; gx <= SPAWN_RADIUS; gx++) {
      for (let gz = -SPAWN_RADIUS; gz <= SPAWN_RADIUS; gz++) {
        ensureGroundBlocksNear(gx * GROUND_BLOCK_SIZE, gz * GROUND_BLOCK_SIZE);
      }
    }
    // Also generate at player's exact spawn position (0, 10) to be safe
    ensureGroundBlocksNear(0, 10);
    ensureGroundBlocksNear(0, 8);
    ensureGroundBlocksNear(0, 12);
    console.log(`Generated ${groundBlocks.length} ground blocks for spawn area`);
    // Debug: Log first few block positions
    if (groundBlocks.length > 0) {
      console.log('Sample block positions:', groundBlocks.slice(0, 3).map(b => `(${b.position.x}, ${b.position.y}, ${b.position.z})`));
    }
    // ===== END PRE-GENERATE =====

    // ===== END PHASE 2 =====

    // ===== PHASE 3: WATER =====
    // A beautiful blue lake with gentle animation
    
    /**
     * Creates a water body at position (x, z)
     * @param {number} x - Center X position
     * @param {number} z - Center Z position
     * @param {number} width - Width of water
     * @param {number} depth - Depth (Z direction) of water
     */
    function makeWater(x, z, width = 30, depth = 20) {
      const waterGeo = new THREE.PlaneGeometry(width, depth, 20, 20);
      const waterMat = new THREE.MeshStandardMaterial({
        color: 0x0077be,        // Ocean blue
        transparent: true,
        opacity: 0.7,
        side: THREE.DoubleSide,
      });
      
      const water = new THREE.Mesh(waterGeo, waterMat);
      water.rotation.x = -Math.PI / 2;
      water.position.set(x, 0.3, z); // Slightly above ground
      water.userData.type = 'water';
      water.userData.time = 0;
      water.userData.originalY = 0.3;
      scene.add(water);
      
      return water;
    }

    // Create a lake on one side of the map
    const lake = makeWater(-35, -60, 35, 25);

    // Animate water (gentle bobbing)
    function animateWater(delta) {
      if (lake) {
        lake.userData.time += delta;
        // Gentle up/down motion
        lake.position.y = lake.userData.originalY + Math.sin(lake.userData.time * 2) * 0.15;
        
        // Also animate vertices for wave effect
        const positions = lake.geometry.attributes.position;
        for (let i = 0; i < positions.count; i++) {
          const x = positions.getX(i);
          const z = positions.getZ(i);
          // Create wave pattern
          const wave = Math.sin(x * 0.5 + lake.userData.time * 3) * 0.2 +
                       Math.sin(z * 0.3 + lake.userData.time * 2) * 0.15;
          positions.setY(i, wave);
        }
        positions.needsUpdate = true;
      }
    }

    // ===== END PHASE 3 =====

    // ===== COLLISION DETECTION SYSTEM =====
    // Prevents player from walking through solid objects
    
    const PLAYER_RADIUS = 1.5; // Player collision radius
    const PLAYER_HEIGHT = 5;   // Player eye height
    
    /**
     * Check if a position collides with any solid object
     * @param {THREE.Vector3} position - Position to check
     * @returns {boolean} true if collision detected
     */
    function checkCollision(position) {
      const playerX = position.x;
      const playerZ = position.z;
      
      // Check collision with blocks
      for (const block of blocks) {
        const dx = playerX - block.position.x;
        const dz = playerZ - block.position.z;
        const dist = Math.sqrt(dx * dx + dz * dz);
        
        // Block collision (blocks are 4x4, so radius ~2.8 + player radius)
        if (dist < 2.8 + PLAYER_RADIUS) {
          return true;
        }
      }
      
      // Check collision with tree trunks
      for (const tree of trees) {
        const dx = playerX - tree.position.x;
        const dz = playerZ - tree.position.z;
        const dist = Math.sqrt(dx * dx + dz * dz);
        
        // Tree trunk collision (trunks are ~2 wide)
        if (dist < 1.5 + PLAYER_RADIUS) {
          return true;
        }
      }
      
      // Check collision with cave walls
      for (const cave of caves) {
        // Get cave parts that are solid walls
        cave.traverse((child) => {
          if (child.isMesh && child.userData.type === 'stone') {
            const worldPos = new THREE.Vector3();
            child.getWorldPosition(worldPos);
            
            const dx = playerX - worldPos.x;
            const dz = playerZ - worldPos.z;
            const dist = Math.sqrt(dx * dx + dz * dz);
            
            if (dist < 1.5 + PLAYER_RADIUS) {
              return true;
            }
          }
        });
      }
      
      return false;
    }
    
    /**
     * Try to move to a new position, with collision detection
     * Returns the actual position after collision resolution
     */
    function tryMove(currentPos, newPos) {
      // If no collision at new position, allow full movement
      if (!checkCollision(newPos)) {
        return newPos.clone();
      }
      
      // Try sliding along X axis only
      const slideX = new THREE.Vector3(newPos.x, currentPos.y, currentPos.z);
      if (!checkCollision(slideX)) {
        return slideX;
      }
      
      // Try sliding along Z axis only
      const slideZ = new THREE.Vector3(currentPos.x, currentPos.y, newPos.z);
      if (!checkCollision(slideZ)) {
        return slideZ;
      }
      
      // Can't move at all - stay in place
      return currentPos.clone();
    }

    // ===== END COLLISION DETECTION =====

    // Lights
    const sun = new THREE.DirectionalLight(0xffffff, 1.5);
    sun.position.set(50, 100, 50);
    sun.castShadow = true;
    scene.add(sun);
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    // ===== SUN & MOON VISUALS =====
    const SKY_RADIUS = 150; // Distance from player to sun/moon
    
    // Create the SUN - big glowing orange ball!
    const sunMesh = new THREE.Mesh(
      new THREE.SphereGeometry(15, 32, 32),
      new THREE.MeshBasicMaterial({
        color: 0xffdd44,
        transparent: true,
        opacity: 1,
      })
    );
    // Sun glow effect (bigger transparent sphere around it)
    const sunGlow = new THREE.Mesh(
      new THREE.SphereGeometry(25, 32, 32),
      new THREE.MeshBasicMaterial({
        color: 0xffaa00,
        transparent: true,
        opacity: 0.3,
      })
    );
    sunMesh.add(sunGlow);
    scene.add(sunMesh);
    
    // Create the MOON - silvery white ball with halo ring!
    const moonMesh = new THREE.Group();
    
    // Moon sphere
    const moonSphere = new THREE.Mesh(
      new THREE.SphereGeometry(12, 32, 32),
      new THREE.MeshBasicMaterial({
        color: 0xeeeeee,
        transparent: true,
        opacity: 1,
      })
    );
    moonMesh.add(moonSphere);
    
    // Moon glow effect
    const moonGlow = new THREE.Mesh(
      new THREE.SphereGeometry(18, 32, 32),
      new THREE.MeshBasicMaterial({
        color: 0xaaaaff,
        transparent: true,
        opacity: 0.2,
      })
    );
    moonMesh.add(moonGlow);
    
    // Moon halo ring - sparkly ring around the moon!
    const moonHalo = new THREE.Mesh(
      new THREE.RingGeometry(14, 18, 32),
      new THREE.MeshBasicMaterial({
        color: 0xffffff,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.3,
      })
    );
    moonMesh.add(moonHalo);
    
    scene.add(moonMesh);

    // Player stuff
    // Grass blocks at y=2 have top at y=4, player eyes are 4 units above feet, so spawn at y=8
    camera.position.set(0, 8, 10);
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, canJump = true;

    // ===== MINECRAFT-STYLE BLOCKY GUN =====
    const gun = new THREE.Group();
    
    // Gun body (main block)
    const gunBody = new THREE.Mesh(
      new THREE.BoxGeometry(0.15, 0.12, 0.4),
      new THREE.MeshStandardMaterial({ color: 0x4a4a4a })
    );
    gun.add(gunBody);
    
    // Gun barrel (front block)
    const gunBarrel = new THREE.Mesh(
      new THREE.BoxGeometry(0.08, 0.08, 0.25),
      new THREE.MeshStandardMaterial({ color: 0x333333 })
    );
    gunBarrel.position.set(0, 0.02, -0.3);
    gun.add(gunBarrel);
    
    // Gun handle (bottom block)
    const gunHandle = new THREE.Mesh(
      new THREE.BoxGeometry(0.1, 0.18, 0.12),
      new THREE.MeshStandardMaterial({ color: 0x8B4513 }) // Wood brown
    );
    gunHandle.position.set(0, -0.12, 0.08);
    gun.add(gunHandle);
    
    // Gun sight (top tiny block)
    const gunSight = new THREE.Mesh(
      new THREE.BoxGeometry(0.03, 0.04, 0.03),
      new THREE.MeshStandardMaterial({ color: 0x666666 })
    );
    gunSight.position.set(0, 0.08, -0.1);
    gun.add(gunSight);

    // Muzzle flash (hidden until shooting)
    const muzzleFlash = new THREE.Mesh(
      new THREE.BoxGeometry(0.15, 0.15, 0.1),
      new THREE.MeshBasicMaterial({ color: 0xffff00 })
    );
    muzzleFlash.position.set(0, 0.02, -0.45);
    muzzleFlash.visible = false;
    gun.add(muzzleFlash);

    // Position gun in bottom-right of view
    gun.position.set(0.35, -0.25, -0.5);
    gun.rotation.y = -0.1; // Slight angle
    camera.add(gun);
    scene.add(camera); // Need to add camera to scene for gun to render

    // ===== SWING ANIMATION SYSTEM =====
    // Minecraft-style "hack" animation for mining and attacking
    const swingAnimation = {
      active: false,
      progress: 0,
      duration: 0.25, // seconds for full swing
      baseRotationX: 0,
      baseRotationZ: 0,
      basePositionY: -0.25,
    };

    function playSwingAnimation() {
      if (swingAnimation.active) return; // Don't interrupt ongoing swing
      swingAnimation.active = true;
      swingAnimation.progress = 0;
    }

    function updateSwingAnimation(delta) {
      if (!swingAnimation.active) return;

      swingAnimation.progress += delta / swingAnimation.duration;
      
      if (swingAnimation.progress >= 1) {
        // Animation complete - reset to default
        swingAnimation.active = false;
        swingAnimation.progress = 0;
        gun.rotation.x = swingAnimation.baseRotationX;
        gun.rotation.z = swingAnimation.baseRotationZ;
        gun.position.y = swingAnimation.basePositionY;
        return;
      }

      // Swing curve: down fast (0-0.4), up slow (0.4-1.0)
      const p = swingAnimation.progress;
      let swingAmount;
      
      if (p < 0.4) {
        // Swing down - fast, dramatic
        swingAmount = Math.sin((p / 0.4) * Math.PI * 0.5);
      } else {
        // Swing back up - slower
        swingAmount = Math.cos(((p - 0.4) / 0.6) * Math.PI * 0.5);
      }

      // Apply swing rotation and position offset
      gun.rotation.x = swingAnimation.baseRotationX - swingAmount * 0.8; // Rotate down
      gun.rotation.z = swingAnimation.baseRotationZ + swingAmount * 0.3; // Slight twist
      gun.position.y = swingAnimation.basePositionY - swingAmount * 0.1; // Move down slightly
    }
    // ===== END SWING ANIMATION =====

    // Score tracking
    let score = 0;
    const scoreDisplay = document.getElementById('score');

    // Show floating "Score +1!" at explosion spot
    function showScorePopup(position3D) {
      // Convert 3D position to screen position
      const pos = position3D.clone();
      pos.project(camera);
      const x = (pos.x * 0.5 + 0.5) * window.innerWidth;
      const y = (-pos.y * 0.5 + 0.5) * window.innerHeight;

      // Create the popup
      const popup = document.createElement('div');
      popup.className = 'score-popup';
      popup.textContent = 'Score +1!';
      popup.style.left = x + 'px';
      popup.style.top = y + 'px';
      document.body.appendChild(popup);

      // Remove after animation (2 seconds)
      setTimeout(() => popup.remove(), 2000);
    }

    // Shooting!
    const bullets = [];
    const BULLET_MAX_BOUNCES = 3;
    const BULLET_BOUNCE_ENERGY_LOSS = 0.7; // Keep 70% speed each bounce
    const BULLET_MIN_SPEED = 5; // Remove bullet if slower than this

    function shoot() {
      soundSystem.shoot(); // Pew pew!
      
      const bullet = new THREE.Mesh(
        new THREE.SphereGeometry(0.3),
        new THREE.MeshBasicMaterial({ color: 0xffff00 })
      );
      bullet.position.copy(camera.position);
      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);
      bullet.velocity = dir.multiplyScalar(50);
      bullet.bounceCount = 0; // Track bounces for ricochet physics
      bullet.maxBounces = BULLET_MAX_BOUNCES;
      scene.add(bullet);
      bullets.push(bullet);

      // Muzzle flash!
      muzzleFlash.visible = true;
      muzzleFlash.material.color.setHex(0xffff00);
      setTimeout(() => {
        muzzleFlash.material.color.setHex(0xff8800);
        setTimeout(() => {
          muzzleFlash.visible = false;
        }, 30);
      }, 30);

      // Gun recoil animation
      gun.position.z += 0.05;
      gun.rotation.x -= 0.1;
      setTimeout(() => {
        gun.position.z = -0.5;
        gun.rotation.x = 0;
      }, 80);
    }

    // ===== PHASE 4: INVENTORY SYSTEM =====
    // Expandable inventory with hotbar UI
    
    // Item definitions (easy to add more!)
    const itemTypes = {
      wood: { name: 'Wood', color: '#8B4513', icon: 'ü™µ' },
      stone: { name: 'Stone', color: '#555555', icon: 'ü™®' },
      leaves: { name: 'Leaves', color: '#228B22', icon: 'üçÉ' },
      treasure: { name: 'Treasure', color: '#ffd700', icon: 'üíé' },
      dirt: { name: 'Dirt', color: '#8B5A2B', icon: 'üü´' },
      grass: { name: 'Grass Block', color: '#3ab33a', icon: 'üå±' },
      // Animal drops
      // Raw meat - edible but restores less hunger than cooked
      raw_porkchop: { name: 'Raw Porkchop', color: '#FFA0A0', icon: 'ü•©', isEdible: true, hungerValue: 3 },
      raw_beef: { name: 'Raw Beef', color: '#FF6666', icon: 'ü•©', isEdible: true, hungerValue: 3 },
      raw_chicken: { name: 'Raw Chicken', color: '#FFCCCC', icon: 'üçó', isEdible: true, hungerValue: 2 },
      raw_mutton: { name: 'Raw Mutton', color: '#FF8888', icon: 'üçñ', isEdible: true, hungerValue: 2 },
      leather: { name: 'Leather', color: '#8B4513', icon: 'üü´' },
      feather: { name: 'Feather', color: '#FFFFFF', icon: 'ü™∂' },
      wool: { name: 'Wool', color: '#EEEEEE', icon: 'üß∂' },
      // Cooked food (edible - hungerValue = hunger restored when eaten)
      cooked_porkchop: { name: 'Cooked Porkchop', color: '#CC6633', icon: 'üçñ', isEdible: true, hungerValue: 8 },
      cooked_beef: { name: 'Steak', color: '#993300', icon: 'ü•©', isEdible: true, hungerValue: 8 },
      cooked_chicken: { name: 'Cooked Chicken', color: '#CC9966', icon: 'üçó', isEdible: true, hungerValue: 6 },
      cooked_mutton: { name: 'Cooked Mutton', color: '#996633', icon: 'üçñ', isEdible: true, hungerValue: 6 },
      // Crafting materials
      stick: { name: 'Stick', color: '#8B6914', icon: 'ü•¢' },
      planks: { name: 'Planks', color: '#C4A000', icon: 'üü´' },
      cobblestone: { name: 'Cobblestone', color: '#777777', icon: 'ü™®' },
      // Tools - Wooden
      wooden_pickaxe: { name: 'Wooden Pickaxe', color: '#8B6914', icon: '‚õèÔ∏è', isTool: true, toolType: 'pickaxe', tier: 'wood', durability: 59, miningSpeed: 2, damage: 2 },
      wooden_axe: { name: 'Wooden Axe', color: '#8B6914', icon: 'ü™ì', isTool: true, toolType: 'axe', tier: 'wood', durability: 59, miningSpeed: 2, damage: 3 },
      wooden_shovel: { name: 'Wooden Shovel', color: '#8B6914', icon: 'ü•Ñ', isTool: true, toolType: 'shovel', tier: 'wood', durability: 59, miningSpeed: 2, damage: 1 },
      wooden_sword: { name: 'Wooden Sword', color: '#8B6914', icon: 'üó°Ô∏è', isTool: true, toolType: 'sword', tier: 'wood', durability: 59, miningSpeed: 1, damage: 4 },
      // Tools - Stone
      stone_pickaxe: { name: 'Stone Pickaxe', color: '#888888', icon: '‚õèÔ∏è', isTool: true, toolType: 'pickaxe', tier: 'stone', durability: 131, miningSpeed: 4, damage: 3 },
      stone_axe: { name: 'Stone Axe', color: '#888888', icon: 'ü™ì', isTool: true, toolType: 'axe', tier: 'stone', durability: 131, miningSpeed: 4, damage: 4 },
      stone_shovel: { name: 'Stone Shovel', color: '#888888', icon: 'ü•Ñ', isTool: true, toolType: 'shovel', tier: 'stone', durability: 131, miningSpeed: 4, damage: 2 },
      stone_sword: { name: 'Stone Sword', color: '#888888', icon: 'üó°Ô∏è', isTool: true, toolType: 'sword', tier: 'stone', durability: 131, miningSpeed: 1, damage: 5 },
      // Tools - Iron
      iron_pickaxe: { name: 'Iron Pickaxe', color: '#DDDDDD', icon: '‚õèÔ∏è', isTool: true, toolType: 'pickaxe', tier: 'iron', durability: 250, miningSpeed: 6, damage: 4 },
      iron_axe: { name: 'Iron Axe', color: '#DDDDDD', icon: 'ü™ì', isTool: true, toolType: 'axe', tier: 'iron', durability: 250, miningSpeed: 6, damage: 5 },
      iron_shovel: { name: 'Iron Shovel', color: '#DDDDDD', icon: 'ü•Ñ', isTool: true, toolType: 'shovel', tier: 'iron', durability: 250, miningSpeed: 6, damage: 3 },
      iron_sword: { name: 'Iron Sword', color: '#DDDDDD', icon: 'üó°Ô∏è', isTool: true, toolType: 'sword', tier: 'iron', durability: 250, miningSpeed: 1, damage: 6 },
      // Tools - Diamond
      diamond_pickaxe: { name: 'Diamond Pickaxe', color: '#00FFFF', icon: '‚õèÔ∏è', isTool: true, toolType: 'pickaxe', tier: 'diamond', durability: 1561, miningSpeed: 8, damage: 5 },
      diamond_axe: { name: 'Diamond Axe', color: '#00FFFF', icon: 'ü™ì', isTool: true, toolType: 'axe', tier: 'diamond', durability: 1561, miningSpeed: 8, damage: 6 },
      diamond_shovel: { name: 'Diamond Shovel', color: '#00FFFF', icon: 'ü•Ñ', isTool: true, toolType: 'shovel', tier: 'diamond', durability: 1561, miningSpeed: 8, damage: 4 },
      diamond_sword: { name: 'Diamond Sword', color: '#00FFFF', icon: 'üó°Ô∏è', isTool: true, toolType: 'sword', tier: 'diamond', durability: 1561, miningSpeed: 1, damage: 7 },
      // Ores and ingots
      coal: { name: 'Coal', color: '#222222', icon: '‚ö´', isFuel: true, burnTime: 8 },
      iron_ore: { name: 'Iron Ore', color: '#D8AF93', icon: 'ü™®' },
      gold_ore: { name: 'Gold Ore', color: '#FFD700', icon: 'ü™®' },
      diamond: { name: 'Diamond', color: '#00FFFF', icon: 'üíé' },
      iron_ingot: { name: 'Iron Ingot', color: '#DDDDDD', icon: 'üî©' },
      gold_ingot: { name: 'Gold Ingot', color: '#FFD700', icon: 'ü•á' },
      // Furnace
      furnace: { name: 'Furnace', color: '#555555', icon: 'üî•', isPlaceable: true, isFurnace: true },
    };

    // Inventory state
    const inventory = {
      slots: [
        null, null, null, null, null, null, null, null, null // 9 slots (index 0-8)
      ],
      selectedSlot: 0, // Currently selected slot (0-8)
    };

    // Get hotbar DOM elements
    const hotbarSlots = document.querySelectorAll('.hotbar-slot');

    /**
     * Select a hotbar slot (0-8)
     */
    function selectSlot(slotIndex) {
      if (slotIndex < 0 || slotIndex > 8) return;
      
      // Update state
      inventory.selectedSlot = slotIndex;
      
      // Update UI
      hotbarSlots.forEach((slot, i) => {
        slot.classList.toggle('selected', i === slotIndex);
      });
    }

    /**
     * Add item to inventory (finds first empty slot or stacks)
     * @returns {boolean} true if item was added
     */
    function addToInventory(itemType, count = 1) {
      const itemDef = itemTypes[itemType];
      
      // Tools don't stack - each needs its own slot
      if (itemDef && itemDef.isTool) {
        for (let i = 0; i < inventory.slots.length; i++) {
          if (!inventory.slots[i]) {
            inventory.slots[i] = { 
              type: itemType, 
              count: 1,
              durability: itemDef.durability // Initialize durability
            };
            updateHotbarUI();
            return true;
          }
        }
        return false; // No empty slots for tool
      }
      
      // First try to stack with existing items
      for (let i = 0; i < inventory.slots.length; i++) {
        const slot = inventory.slots[i];
        if (slot && slot.type === itemType) {
          slot.count += count;
          updateHotbarUI();
          return true;
        }
      }
      
      // Find first empty slot
      for (let i = 0; i < inventory.slots.length; i++) {
        if (!inventory.slots[i]) {
          inventory.slots[i] = { type: itemType, count };
          updateHotbarUI();
          return true;
        }
      }
      
      return false; // Inventory full
    }

    /**
     * Update the hotbar UI to match inventory state
     */
    function updateHotbarUI() {
      hotbarSlots.forEach((slotEl, i) => {
        const slotData = inventory.slots[i];
        
        // Remove old content (except slot number)
        const oldIcon = slotEl.querySelector('.item-icon');
        const oldCount = slotEl.querySelector('.item-count');
        const oldDurability = slotEl.querySelector('.durability-bar');
        if (oldIcon) oldIcon.remove();
        if (oldCount) oldCount.remove();
        if (oldDurability) oldDurability.remove();
        
        if (slotData) {
          const itemDef = itemTypes[slotData.type];
          if (itemDef) {
            // Add icon
            const icon = document.createElement('div');
            icon.className = 'item-icon';
            icon.textContent = itemDef.icon;
            icon.style.fontSize = '24px';
            slotEl.appendChild(icon);
            
            // Add count (only for stackable items, not tools)
            if (!itemDef.isTool) {
              const count = document.createElement('span');
              count.className = 'item-count';
              count.textContent = slotData.count;
              slotEl.appendChild(count);
            }
            
            // Add durability bar for tools
            if (itemDef.isTool && slotData.durability !== undefined) {
              const durBar = document.createElement('div');
              durBar.className = 'durability-bar';
              durBar.style.cssText = `
                position: absolute;
                bottom: 4px;
                left: 4px;
                right: 4px;
                height: 3px;
                background: #333;
                border-radius: 1px;
              `;
              const durFill = document.createElement('div');
              const durPercent = slotData.durability / itemDef.durability;
              const durColor = durPercent > 0.6 ? '#00ff00' : durPercent > 0.3 ? '#ffff00' : '#ff0000';
              durFill.style.cssText = `
                width: ${durPercent * 100}%;
                height: 100%;
                background: ${durColor};
                border-radius: 1px;
              `;
              durBar.appendChild(durFill);
              slotEl.appendChild(durBar);
            }
          }
        }
      });
    }

    // Initialize with some starting items (for testing)
    addToInventory('planks', 10);
    addToInventory('stick', 8);
    addToInventory('cobblestone', 10);
    addToInventory('coal', 5);

    // ===== END PHASE 4 =====

    // ===== MINECRAFT INVENTORY SYSTEM: ITEM DROPS & PICKUP =====
    // Dropped items in the world (3D objects that can be picked up)
    const droppedItems = [];

    /**
     * Item type to 3D color mapping for dropped items
     */
    const itemColors = {
      wood: 0x8B4513,
      stone: 0x555555,
      leaves: 0x228B22,
      treasure: 0xffd700,
      dirt: 0x8B5A2B,
      block: 0xff00ff, // Generic colored blocks
    };

    /**
     * Spawns a dropped item in the world (Minecraft-style floating cube)
     * @param {string} itemType - Type of item (wood, stone, etc.)
     * @param {THREE.Vector3} position - Where to spawn
     * @param {number} color - Optional override color (for colored blocks)
     */
    function spawnDroppedItem(itemType, position, color = null) {
      const itemColor = color || itemColors[itemType] || 0xffffff;
      
      // Create the dropped item mesh (small cube)
      const geometry = new THREE.BoxGeometry(0.6, 0.6, 0.6);
      const material = new THREE.MeshStandardMaterial({
        color: itemColor,
        emissive: itemColor,
        emissiveIntensity: 0.3, // Slight glow
      });
      
      const droppedItem = new THREE.Mesh(geometry, material);
      droppedItem.position.copy(position);
      droppedItem.position.y = 5; // Float above grass (grass top at y=4)
      
      // Store item data
      droppedItem.userData = {
        type: 'droppedItem',
        itemType: itemType,
        color: itemColor,
        spawnTime: Date.now(),
        bobOffset: Math.random() * Math.PI * 2, // Random start phase for bobbing
        lifetime: 60000, // Despawn after 60 seconds
        beingPickedUp: false,
      };
      
      scene.add(droppedItem);
      droppedItems.push(droppedItem);
      
      return droppedItem;
    }

    /**
     * Animate all dropped items (bob + spin + magnetic pickup)
     */
    function animateDroppedItems(delta) {
      const playerPos = camera.position;
      const pickupRadius = 3; // Start pulling items when this close
      const collectRadius = 1.5; // Actually pick up when this close
      const magnetSpeed = 15; // How fast items fly toward player
      
      for (let i = droppedItems.length - 1; i >= 0; i--) {
        const item = droppedItems[i];
        const data = item.userData;
        
        // Check for despawn
        if (Date.now() - data.spawnTime > data.lifetime) {
          scene.remove(item);
          droppedItems.splice(i, 1);
          continue;
        }
        
        // Calculate distance to player
        const dx = playerPos.x - item.position.x;
        const dz = playerPos.z - item.position.z;
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        // Magnetic pull when close
        if (distance < pickupRadius && !data.beingPickedUp) {
          const pullStrength = 1 - (distance / pickupRadius); // Stronger when closer
          item.position.x += dx * pullStrength * magnetSpeed * delta;
          item.position.z += dz * pullStrength * magnetSpeed * delta;
          
          // Also rise toward player height
          const dy = playerPos.y - item.position.y;
          item.position.y += dy * pullStrength * magnetSpeed * delta * 0.5;
        }
        
        // Collect item when very close
        if (distance < collectRadius) {
          data.beingPickedUp = true;
          
          // Add to inventory
          const added = addToInventory(data.itemType, 1);
          
          if (added) {
            // Show pickup popup
            showItemPickupPopup(data.itemType, item.position);
            soundSystem.itemPickup(); // Pop!
            
            // Shrink and remove animation
            const shrinkInterval = setInterval(() => {
              item.scale.multiplyScalar(0.8);
              if (item.scale.x < 0.1) {
                clearInterval(shrinkInterval);
                scene.remove(item);
                const idx = droppedItems.indexOf(item);
                if (idx > -1) droppedItems.splice(idx, 1);
              }
            }, 30);
          } else {
            // Inventory full - push item away
            data.beingPickedUp = false;
            item.position.x -= dx * 0.5;
            item.position.z -= dz * 0.5;
          }
          continue;
        }
        
        // Bobbing animation (up and down)
        const bobSpeed = 2;
        const bobHeight = 0.3;
        const baseY = 1.2;
        item.position.y = baseY + Math.sin(Date.now() * 0.003 + data.bobOffset) * bobHeight;
        
        // Spinning animation
        item.rotation.y += delta * 2;
      }
    }

    /**
     * Show a pickup notification
     */
    function showItemPickupPopup(itemType, position3D) {
      const itemDef = itemTypes[itemType];
      const icon = itemDef ? itemDef.icon : 'üì¶';
      const name = itemDef ? itemDef.name : itemType;
      
      const pos = position3D.clone();
      pos.project(camera);
      const x = (pos.x * 0.5 + 0.5) * window.innerWidth;
      const y = (-pos.y * 0.5 + 0.5) * window.innerHeight;
      
      const popup = document.createElement('div');
      popup.className = 'score-popup';
      popup.innerHTML = `${icon} +1 ${name}`;
      popup.style.fontSize = '28px';
      popup.style.color = '#90EE90'; // Light green for pickup
      popup.style.left = x + 'px';
      popup.style.top = y + 'px';
      document.body.appendChild(popup);
      
      setTimeout(() => popup.remove(), 1500);
    }

    // ===== END ITEM DROPS & PICKUP =====

    // ===== PASSIVE MOBS SYSTEM =====
    // Minecraft-style animals: Pig, Cow, Chicken, Sheep
    
    const mobs = []; // All active mobs in the world
    const MOB_CONFIG = {
      maxMobs: 15,
      spawnRadius: 40,
      despawnRadius: 60,
      spawnCooldown: 10, // seconds between spawn attempts
    };
    let mobSpawnTimer = 0;
    
    // Mob type definitions
    const mobTypes = {
      pig: {
        health: 10,
        speed: 2.5,
        bodyColor: 0xFFC0CB,
        drops: [{ type: 'raw_porkchop', min: 1, max: 3 }],
        sound: () => soundSystem.pigOink(),
        idleSound: 0.02, // Chance per frame to make sound
      },
      cow: {
        health: 10,
        speed: 2.0,
        bodyColor: 0x8B4513,
        spots: 0xFFFFFF,
        drops: [{ type: 'raw_beef', min: 1, max: 3 }, { type: 'leather', min: 0, max: 2 }],
        sound: () => soundSystem.cowMoo(),
        idleSound: 0.01,
      },
      chicken: {
        health: 4,
        speed: 3.0,
        bodyColor: 0xFFFFFF,
        drops: [{ type: 'raw_chicken', min: 1, max: 1 }, { type: 'feather', min: 0, max: 2 }],
        sound: () => soundSystem.chickenCluck(),
        idleSound: 0.03,
      },
      sheep: {
        health: 8,
        speed: 2.3,
        bodyColor: 0xEEEEEE,
        drops: [{ type: 'raw_mutton', min: 1, max: 2 }, { type: 'wool', min: 1, max: 1 }],
        sound: () => soundSystem.sheepBaa(),
        idleSound: 0.015,
      },
    };
    
    /**
     * Create a blocky mob model (Minecraft-style)
     */
    function createMobModel(type) {
      const group = new THREE.Group();
      const def = mobTypes[type];
      
      if (type === 'pig') {
        // Body
        const body = new THREE.Mesh(
          new THREE.BoxGeometry(1.0, 0.75, 0.5),
          new THREE.MeshStandardMaterial({ color: def.bodyColor })
        );
        body.position.y = 0.5;
        group.add(body);
        
        // Head
        const head = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 0.5, 0.5),
          new THREE.MeshStandardMaterial({ color: def.bodyColor })
        );
        head.position.set(0.55, 0.65, 0);
        group.add(head);
        
        // Snout
        const snout = new THREE.Mesh(
          new THREE.BoxGeometry(0.2, 0.2, 0.15),
          new THREE.MeshStandardMaterial({ color: 0xFFAAAA })
        );
        snout.position.set(0.8, 0.55, 0);
        group.add(snout);
        
        // Legs (4)
        const legGeo = new THREE.BoxGeometry(0.2, 0.4, 0.2);
        const legMat = new THREE.MeshStandardMaterial({ color: def.bodyColor });
        [[0.3, 0.2], [0.3, -0.2], [-0.3, 0.2], [-0.3, -0.2]].forEach(([x, z]) => {
          const leg = new THREE.Mesh(legGeo, legMat);
          leg.position.set(x, 0.2, z);
          group.add(leg);
        });
      } else if (type === 'cow') {
        // Body (larger than pig)
        const body = new THREE.Mesh(
          new THREE.BoxGeometry(1.2, 0.9, 0.6),
          new THREE.MeshStandardMaterial({ color: def.bodyColor })
        );
        body.position.y = 0.7;
        group.add(body);
        
        // Spots
        const spot1 = new THREE.Mesh(
          new THREE.BoxGeometry(0.3, 0.3, 0.01),
          new THREE.MeshStandardMaterial({ color: def.spots })
        );
        spot1.position.set(0, 0.7, 0.31);
        group.add(spot1);
        
        // Head
        const head = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 0.55, 0.5),
          new THREE.MeshStandardMaterial({ color: def.bodyColor })
        );
        head.position.set(0.7, 0.85, 0);
        group.add(head);
        
        // Horns
        const hornMat = new THREE.MeshStandardMaterial({ color: 0xDDDDDD });
        const horn1 = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.2, 0.08), hornMat);
        horn1.position.set(0.7, 1.15, 0.15);
        group.add(horn1);
        const horn2 = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.2, 0.08), hornMat);
        horn2.position.set(0.7, 1.15, -0.15);
        group.add(horn2);
        
        // Legs
        const legGeo = new THREE.BoxGeometry(0.2, 0.5, 0.2);
        const legMat = new THREE.MeshStandardMaterial({ color: def.bodyColor });
        [[0.4, 0.25], [0.4, -0.25], [-0.4, 0.25], [-0.4, -0.25]].forEach(([x, z]) => {
          const leg = new THREE.Mesh(legGeo, legMat);
          leg.position.set(x, 0.25, z);
          group.add(leg);
        });
      } else if (type === 'chicken') {
        // Body (small, oval-ish)
        const body = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 0.35, 0.3),
          new THREE.MeshStandardMaterial({ color: def.bodyColor })
        );
        body.position.y = 0.35;
        group.add(body);
        
        // Head
        const head = new THREE.Mesh(
          new THREE.BoxGeometry(0.25, 0.25, 0.25),
          new THREE.MeshStandardMaterial({ color: def.bodyColor })
        );
        head.position.set(0.25, 0.55, 0);
        group.add(head);
        
        // Beak
        const beak = new THREE.Mesh(
          new THREE.BoxGeometry(0.1, 0.08, 0.05),
          new THREE.MeshStandardMaterial({ color: 0xFFA500 })
        );
        beak.position.set(0.38, 0.52, 0);
        group.add(beak);
        
        // Comb (red thing on head)
        const comb = new THREE.Mesh(
          new THREE.BoxGeometry(0.08, 0.12, 0.03),
          new THREE.MeshStandardMaterial({ color: 0xFF0000 })
        );
        comb.position.set(0.25, 0.72, 0);
        group.add(comb);
        
        // Legs (thin)
        const legMat = new THREE.MeshStandardMaterial({ color: 0xFFA500 });
        const leg1 = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.2, 0.05), legMat);
        leg1.position.set(0.08, 0.1, 0);
        group.add(leg1);
        const leg2 = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.2, 0.05), legMat);
        leg2.position.set(-0.08, 0.1, 0);
        group.add(leg2);
      } else if (type === 'sheep') {
        // Body (fluffy looking - larger box)
        const body = new THREE.Mesh(
          new THREE.BoxGeometry(1.1, 0.85, 0.7),
          new THREE.MeshStandardMaterial({ color: def.bodyColor })
        );
        body.position.y = 0.65;
        group.add(body);
        
        // Head (darker)
        const head = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 0.45, 0.4),
          new THREE.MeshStandardMaterial({ color: 0x888888 })
        );
        head.position.set(0.6, 0.75, 0);
        group.add(head);
        
        // Legs (darker)
        const legGeo = new THREE.BoxGeometry(0.2, 0.5, 0.2);
        const legMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
        [[0.35, 0.2], [0.35, -0.2], [-0.35, 0.2], [-0.35, -0.2]].forEach(([x, z]) => {
          const leg = new THREE.Mesh(legGeo, legMat);
          leg.position.set(x, 0.25, z);
          group.add(leg);
        });
      }
      
      return group;
    }
    
    /**
     * Spawn a mob at a random position near the player
     */
    function spawnMob(type = null) {
      if (mobs.length >= MOB_CONFIG.maxMobs) return null;
      
      // Random type if not specified
      if (!type) {
        const types = Object.keys(mobTypes);
        type = types[Math.floor(Math.random() * types.length)];
      }
      
      // Random position around player
      const angle = Math.random() * Math.PI * 2;
      const distance = 20 + Math.random() * 20;
      const x = camera.position.x + Math.cos(angle) * distance;
      const z = camera.position.z + Math.sin(angle) * distance;
      
      // Don't spawn in water
      if (lake) {
        const inWater = x > lake.position.x - 17.5 && x < lake.position.x + 17.5 &&
                       z > lake.position.z - 12.5 && z < lake.position.z + 12.5;
        if (inWater) return null;
      }
      
      const def = mobTypes[type];
      const model = createMobModel(type);
      // Spawn on top of grass blocks (grass at y=2, top at y=4, mob feet at y=4)
      model.position.set(x, 4, z);
      scene.add(model);
      
      const mob = {
        type,
        model,
        health: def.health,
        maxHealth: def.health,
        speed: def.speed,
        state: 'idle', // idle, wander, panic
        stateTimer: 2 + Math.random() * 4,
        targetDirection: new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize(),
        invulnerableTimer: 0,
      };
      
      mobs.push(mob);
      return mob;
    }
    
    /**
     * Update mob AI and animation
     */
    function updateMobs(delta) {
      // Spawn timer
      mobSpawnTimer += delta;
      if (mobSpawnTimer >= MOB_CONFIG.spawnCooldown) {
        mobSpawnTimer = 0;
        if (mobs.length < MOB_CONFIG.maxMobs) {
          spawnMob();
        }
      }
      
      // Update each mob
      for (let i = mobs.length - 1; i >= 0; i--) {
        const mob = mobs[i];
        const def = mobTypes[mob.type];
        
        // Invulnerability timer
        if (mob.invulnerableTimer > 0) {
          mob.invulnerableTimer -= delta;
          // Flash effect
          mob.model.visible = Math.floor(mob.invulnerableTimer * 10) % 2 === 0;
        } else {
          mob.model.visible = true;
        }
        
        // Distance check for despawn
        const distToPlayer = mob.model.position.distanceTo(camera.position);
        if (distToPlayer > MOB_CONFIG.despawnRadius) {
          scene.remove(mob.model);
          mobs.splice(i, 1);
          continue;
        }
        
        // Idle sounds
        if (Math.random() < def.idleSound * delta) {
          def.sound();
        }
        
        // AI state machine
        mob.stateTimer -= delta;
        
        if (mob.state === 'panic' && mob.stateTimer <= 0) {
          mob.state = 'idle';
          mob.stateTimer = 2 + Math.random() * 4;
        } else if (mob.state === 'idle' && mob.stateTimer <= 0) {
          mob.state = 'wander';
          mob.stateTimer = 3 + Math.random() * 5;
          mob.targetDirection = new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
        } else if (mob.state === 'wander' && mob.stateTimer <= 0) {
          mob.state = 'idle';
          mob.stateTimer = 2 + Math.random() * 4;
        }
        
        // Movement
        if (mob.state === 'wander' || mob.state === 'panic') {
          const speed = mob.state === 'panic' ? mob.speed * 1.5 : mob.speed;
          const moveDir = mob.targetDirection.clone().multiplyScalar(speed * delta);
          
          // Move mob
          mob.model.position.add(moveDir);
          
          // Keep on ground (grass blocks at y=2 have top at y=4)
          mob.model.position.y = 4;
          
          // Face direction of movement
          if (moveDir.length() > 0.001) {
            mob.model.rotation.y = Math.atan2(moveDir.x, moveDir.z);
          }
          
          // Boundary check - turn around at edges
          if (Math.abs(mob.model.position.x) > 80 || Math.abs(mob.model.position.z) > 80) {
            mob.targetDirection.negate();
          }
          
          // Avoid water
          if (lake) {
            const inWater = mob.model.position.x > lake.position.x - 18 && mob.model.position.x < lake.position.x + 18 &&
                           mob.model.position.z > lake.position.z - 13 && mob.model.position.z < lake.position.z + 13;
            if (inWater) {
              // Move away from water center
              const awayDir = mob.model.position.clone().sub(lake.position);
              awayDir.y = 0;
              awayDir.normalize();
              mob.targetDirection.copy(awayDir);
            }
          }
        }
        
        // Simple leg animation (bob up/down slightly when moving)
        if (mob.state === 'wander' || mob.state === 'panic') {
          mob.model.position.y = 4 + Math.abs(Math.sin(Date.now() * 0.01)) * 0.1;
        }
      }
    }
    
    /**
     * Damage a mob
     */
    function damageMob(mob, amount) {
      if (mob.invulnerableTimer > 0) return;
      
      mob.health -= amount;
      mob.invulnerableTimer = 0.5; // Half second of invulnerability
      soundSystem.mobHurt();
      
      // Enter panic state
      mob.state = 'panic';
      mob.stateTimer = 5;
      
      // Run away from player
      const awayDir = mob.model.position.clone().sub(camera.position);
      awayDir.y = 0;
      awayDir.normalize();
      mob.targetDirection.copy(awayDir);
      
      if (mob.health <= 0) {
        killMob(mob);
      }
    }
    
    /**
     * Kill a mob and drop items
     */
    function killMob(mob) {
      soundSystem.mobDeath();
      
      const def = mobTypes[mob.type];
      const deathPos = mob.model.position.clone();
      
      // Drop items
      def.drops.forEach(drop => {
        const count = drop.min + Math.floor(Math.random() * (drop.max - drop.min + 1));
        for (let i = 0; i < count; i++) {
          const dropPos = deathPos.clone();
          dropPos.x += (Math.random() - 0.5) * 2;
          dropPos.z += (Math.random() - 0.5) * 2;
          spawnDroppedItem(drop.type, dropPos);
        }
      });
      
      // Death particles
      for (let i = 0; i < 5; i++) {
        const spark = new THREE.Mesh(
          new THREE.SphereGeometry(0.15),
          new THREE.MeshBasicMaterial({ color: 0xffffff })
        );
        spark.position.copy(deathPos);
        spark.position.y += 0.5;
        scene.add(spark);
        
        const vel = new THREE.Vector3(
          (Math.random() - 0.5) * 3,
          Math.random() * 2,
          (Math.random() - 0.5) * 3
        );
        let life = 0;
        const timer = setInterval(() => {
          spark.position.add(vel.clone().multiplyScalar(0.05));
          vel.y -= 0.1;
          life++;
          if (life > 15) {
            scene.remove(spark);
            clearInterval(timer);
          }
        }, 50);
      }
      
      // Remove mob
      scene.remove(mob.model);
      const idx = mobs.indexOf(mob);
      if (idx > -1) mobs.splice(idx, 1);
      
      // Score!
      score += 3;
      scoreDisplay.textContent = score;
    }
    
    /**
     * Check if a raycast or bullet hits a mob
     */
    function checkMobHit(position, radius = 1.5) {
      for (const mob of mobs) {
        const dist = position.distanceTo(mob.model.position);
        if (dist < radius) {
          return mob;
        }
      }
      return null;
    }
    
    // Spawn initial passive mobs
    for (let i = 0; i < 5; i++) {
      const angle = Math.random() * Math.PI * 2;
      const dist = 15 + Math.random() * 25;
      const x = Math.cos(angle) * dist;
      const z = Math.sin(angle) * dist;
      
      const types = Object.keys(mobTypes);
      const type = types[Math.floor(Math.random() * types.length)];
      
      const model = createMobModel(type);
      // Spawn on top of grass blocks (grass at y=2, top at y=4)
      model.position.set(x, 4, z);
      scene.add(model);
      
      mobs.push({
        type,
        model,
        health: mobTypes[type].health,
        maxHealth: mobTypes[type].health,
        speed: mobTypes[type].speed,
        state: 'idle',
        stateTimer: 2 + Math.random() * 4,
        targetDirection: new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize(),
        invulnerableTimer: 0,
      });
    }
    // ===== END PASSIVE MOBS =====
    
    // ===== HOSTILE MOBS SYSTEM =====
    // Minecraft-style hostile mobs: Zombie, Skeleton, Spider, Creeper
    
    const hostileMobs = [];
    const HOSTILE_CONFIG = {
      maxMobs: 10,
      spawnRadiusMin: 20,
      spawnRadiusMax: 40,
      despawnRadius: 60,
      spawnCooldown: 15,
      nightOnly: true,
    };
    let hostileSpawnTimer = 0;
    
    // Hostile mob type definitions
    const hostileMobTypes = {
      zombie: {
        health: 20,
        speed: 2.3,
        damage: 3,
        attackCooldown: 1.0,
        attackRange: 2,
        detectionRange: 40,
        bodyColor: 0x00AA77,
        drops: [{ type: 'stone', min: 0, max: 2 }], // Placeholder - should be rotten_flesh
        sound: () => soundSystem.zombieGroan(),
        idleSound: 0.015,
        burnsInSunlight: true,
      },
      skeleton: {
        health: 20,
        speed: 2.5,
        damage: 3,
        attackCooldown: 2.0,
        attackRange: 15,
        detectionRange: 16,
        bodyColor: 0xEEEEEE,
        drops: [{ type: 'stone', min: 0, max: 2 }], // Placeholder - bones and arrows
        sound: () => soundSystem.skeletonRattle(),
        idleSound: 0.01,
        burnsInSunlight: true,
        isRanged: true,
      },
      spider: {
        health: 16,
        speed: 3.0,
        damage: 2,
        attackCooldown: 0.5,
        attackRange: 2,
        detectionRange: 16,
        bodyColor: 0x333333,
        drops: [{ type: 'stone', min: 0, max: 2 }], // Placeholder - string
        sound: () => soundSystem.spiderHiss(),
        idleSound: 0.02,
        burnsInSunlight: false,
        neutralInDay: true,
      },
      creeper: {
        health: 20,
        speed: 2.5,
        damage: 0, // Explosion damage handled separately
        attackCooldown: 0,
        attackRange: 3,
        detectionRange: 16,
        bodyColor: 0x00FF00,
        drops: [{ type: 'stone', min: 0, max: 2 }], // Placeholder - gunpowder
        sound: () => soundSystem.creeperFuse(),
        idleSound: 0,
        burnsInSunlight: false,
        explodes: true,
        fuseDuration: 1.5,
        explosionRadius: 4,
      },
    };
    
    /**
     * Create a hostile mob model
     */
    function createHostileMobModel(type) {
      const group = new THREE.Group();
      const def = hostileMobTypes[type];
      
      if (type === 'zombie') {
        // Body
        const body = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 0.75, 0.25),
          new THREE.MeshStandardMaterial({ color: def.bodyColor })
        );
        body.position.y = 1.1;
        group.add(body);
        
        // Head
        const head = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 0.5, 0.5),
          new THREE.MeshStandardMaterial({ color: def.bodyColor })
        );
        head.position.y = 1.7;
        group.add(head);
        
        // Arms (extended forward - zombie pose!)
        const armMat = new THREE.MeshStandardMaterial({ color: def.bodyColor });
        const leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.6, 0.25), armMat);
        leftArm.position.set(0.35, 1.2, 0.35);
        leftArm.rotation.x = -Math.PI / 2.5;
        group.add(leftArm);
        const rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.6, 0.25), armMat);
        rightArm.position.set(-0.35, 1.2, 0.35);
        rightArm.rotation.x = -Math.PI / 2.5;
        group.add(rightArm);
        
        // Legs (blue pants like original Minecraft zombie)
        const legMat = new THREE.MeshStandardMaterial({ color: 0x3366CC });
        const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.6, 0.25), legMat);
        leftLeg.position.set(0.15, 0.3, 0);
        group.add(leftLeg);
        const rightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.6, 0.25), legMat);
        rightLeg.position.set(-0.15, 0.3, 0);
        group.add(rightLeg);
        
      } else if (type === 'skeleton') {
        // Body (thin)
        const body = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 0.65, 0.2),
          new THREE.MeshStandardMaterial({ color: def.bodyColor })
        );
        body.position.y = 1.1;
        group.add(body);
        
        // Head (skull)
        const head = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 0.5, 0.5),
          new THREE.MeshStandardMaterial({ color: def.bodyColor })
        );
        head.position.y = 1.65;
        group.add(head);
        
        // Eyes (black)
        const eyeMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
        const leftEye = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.05), eyeMat);
        leftEye.position.set(0.12, 1.7, 0.25);
        group.add(leftEye);
        const rightEye = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.05), eyeMat);
        rightEye.position.set(-0.12, 1.7, 0.25);
        group.add(rightEye);
        
        // Arms and legs (thin bones)
        const boneMat = new THREE.MeshStandardMaterial({ color: def.bodyColor });
        [[0.3, 1.1], [-0.3, 1.1]].forEach(([x, y]) => {
          const arm = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.5, 0.15), boneMat);
          arm.position.set(x, y, 0);
          group.add(arm);
        });
        [[0.1, 0.3], [-0.1, 0.3]].forEach(([x, y]) => {
          const leg = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.5, 0.15), boneMat);
          leg.position.set(x, y, 0);
          group.add(leg);
        });
        
      } else if (type === 'spider') {
        // Body (wider, lower)
        const body = new THREE.Mesh(
          new THREE.BoxGeometry(1.0, 0.5, 0.7),
          new THREE.MeshStandardMaterial({ color: def.bodyColor })
        );
        body.position.y = 0.4;
        group.add(body);
        
        // Head
        const head = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 0.4, 0.5),
          new THREE.MeshStandardMaterial({ color: def.bodyColor })
        );
        head.position.set(0.6, 0.35, 0);
        group.add(head);
        
        // Red eyes
        const eyeMat = new THREE.MeshStandardMaterial({ color: 0xFF0000, emissive: 0x660000 });
        const leftEye = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.1, 0.05), eyeMat);
        leftEye.position.set(0.8, 0.4, 0.12);
        group.add(leftEye);
        const rightEye = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.1, 0.05), eyeMat);
        rightEye.position.set(0.8, 0.4, -0.12);
        group.add(rightEye);
        
        // 8 legs
        const legMat = new THREE.MeshStandardMaterial({ color: def.bodyColor });
        [[-0.3, 0.5], [-0.1, 0.6], [0.1, 0.6], [0.3, 0.5]].forEach(([x, len], idx) => {
          // Left side
          const legL = new THREE.Mesh(new THREE.BoxGeometry(0.1, len, 0.1), legMat);
          legL.position.set(x, 0.2, 0.45);
          legL.rotation.z = -0.5;
          group.add(legL);
          // Right side
          const legR = new THREE.Mesh(new THREE.BoxGeometry(0.1, len, 0.1), legMat);
          legR.position.set(x, 0.2, -0.45);
          legR.rotation.z = 0.5;
          group.add(legR);
        });
        
      } else if (type === 'creeper') {
        // Body (tall, thin)
        const body = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 1.0, 0.3),
          new THREE.MeshStandardMaterial({ color: def.bodyColor })
        );
        body.position.y = 1.0;
        group.add(body);
        
        // Head (square)
        const head = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 0.5, 0.5),
          new THREE.MeshStandardMaterial({ color: def.bodyColor })
        );
        head.position.y = 1.75;
        group.add(head);
        
        // Face (creeper face - black)
        const faceMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
        // Eyes
        const leftEye = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.02), faceMat);
        leftEye.position.set(0.1, 1.85, 0.26);
        group.add(leftEye);
        const rightEye = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.02), faceMat);
        rightEye.position.set(-0.1, 1.85, 0.26);
        group.add(rightEye);
        // Mouth (frown)
        const mouth = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.15, 0.02), faceMat);
        mouth.position.set(0, 1.65, 0.26);
        group.add(mouth);
        
        // 4 legs
        const legMat = new THREE.MeshStandardMaterial({ color: def.bodyColor });
        [[0.15, 0.15], [0.15, -0.15], [-0.15, 0.15], [-0.15, -0.15]].forEach(([x, z]) => {
          const leg = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.5, 0.2), legMat);
          leg.position.set(x, 0.25, z);
          group.add(leg);
        });
      }
      
      return group;
    }
    
    /**
     * Spawn a hostile mob
     */
    function spawnHostileMob(type = null) {
      if (hostileMobs.length >= HOSTILE_CONFIG.maxMobs) return null;
      
      // Only spawn at night (unless spider)
      const isNight = timeOfDay < 0.25 || timeOfDay > 0.75;
      if (HOSTILE_CONFIG.nightOnly && !isNight && type !== 'spider') return null;
      
      if (!type) {
        const types = Object.keys(hostileMobTypes);
        type = types[Math.floor(Math.random() * types.length)];
      }
      
      // Spawn away from player but not too far
      const angle = Math.random() * Math.PI * 2;
      const distance = HOSTILE_CONFIG.spawnRadiusMin + Math.random() * (HOSTILE_CONFIG.spawnRadiusMax - HOSTILE_CONFIG.spawnRadiusMin);
      const x = camera.position.x + Math.cos(angle) * distance;
      const z = camera.position.z + Math.sin(angle) * distance;
      
      const def = hostileMobTypes[type];
      const model = createHostileMobModel(type);
      // Spawn on top of grass blocks (grass at y=2, top at y=4)
      model.position.set(x, 4, z);
      scene.add(model);
      
      const mob = {
        type,
        model,
        health: def.health,
        maxHealth: def.health,
        speed: def.speed,
        state: 'wander',
        attackTimer: 0,
        invulnerableTimer: 0,
        targetDirection: new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize(),
        isOnFire: false,
        fuseTimer: 0, // For creepers
        fuseStarted: false,
      };
      
      hostileMobs.push(mob);
      return mob;
    }
    
    /**
     * Update hostile mob AI
     */
    function updateHostileMobs(delta) {
      const isDay = timeOfDay > 0.25 && timeOfDay < 0.75;
      
      // Spawn timer
      hostileSpawnTimer += delta;
      if (hostileSpawnTimer >= HOSTILE_CONFIG.spawnCooldown) {
        hostileSpawnTimer = 0;
        spawnHostileMob();
      }
      
      for (let i = hostileMobs.length - 1; i >= 0; i--) {
        const mob = hostileMobs[i];
        const def = hostileMobTypes[mob.type];
        
        // Invulnerability
        if (mob.invulnerableTimer > 0) {
          mob.invulnerableTimer -= delta;
          mob.model.visible = Math.floor(mob.invulnerableTimer * 10) % 2 === 0;
        } else {
          mob.model.visible = true;
        }
        
        // Despawn check
        const distToPlayer = mob.model.position.distanceTo(camera.position);
        if (distToPlayer > HOSTILE_CONFIG.despawnRadius) {
          scene.remove(mob.model);
          hostileMobs.splice(i, 1);
          continue;
        }
        
        // Burn in sunlight
        if (def.burnsInSunlight && isDay && !mob.isUnderCover) {
          mob.isOnFire = true;
          mob.health -= 1 * delta; // 1 damage per second
          
          // Fire particles
          if (Math.random() < 0.1) {
            const fire = new THREE.Mesh(
              new THREE.SphereGeometry(0.1),
              new THREE.MeshBasicMaterial({ color: 0xFF4400 })
            );
            fire.position.copy(mob.model.position);
            fire.position.y += 1 + Math.random();
            scene.add(fire);
            setTimeout(() => scene.remove(fire), 200);
          }
          
          if (mob.health <= 0) {
            killHostileMob(mob);
            continue;
          }
        } else {
          mob.isOnFire = false;
        }
        
        // Spider becomes neutral in daylight
        if (def.neutralInDay && isDay) {
          mob.state = 'wander';
        }
        
        // Idle sounds
        if (def.idleSound > 0 && Math.random() < def.idleSound * delta) {
          def.sound();
        }
        
        // AI: Chase player if in range
        const inDetectionRange = distToPlayer < def.detectionRange;
        const inAttackRange = distToPlayer < def.attackRange;
        
        if (inDetectionRange && (mob.state !== 'wander' || !def.neutralInDay || !isDay)) {
          mob.state = 'chase';
          
          // Move toward player
          const dirToPlayer = camera.position.clone().sub(mob.model.position);
          dirToPlayer.y = 0;
          dirToPlayer.normalize();
          mob.targetDirection.copy(dirToPlayer);
          
          // Attack if in range
          if (inAttackRange && mob.attackTimer <= 0) {
            // Creeper special: explode
            if (def.explodes) {
              if (!mob.fuseStarted) {
                mob.fuseStarted = true;
                mob.fuseTimer = def.fuseDuration;
                def.sound(); // Hiss!
              }
              
              mob.fuseTimer -= delta;
              // Flash white when about to explode
              mob.model.traverse(child => {
                if (child.material) {
                  const flashIntensity = Math.sin(mob.fuseTimer * 20) > 0 ? 0.5 : 0;
                  child.material.emissive = new THREE.Color(flashIntensity, flashIntensity, flashIntensity);
                }
              });
              
              if (mob.fuseTimer <= 0) {
                // BOOM!
                soundSystem.explosion();
                const explosionPos = mob.model.position.clone();
                
                // Damage player if close
                const playerDist = explosionPos.distanceTo(camera.position);
                if (playerDist < def.explosionRadius * 2) {
                  const damage = Math.floor(20 * (1 - playerDist / (def.explosionRadius * 2)));
                  takeDamage(damage, 'creeper');
                }
                
                // Visual explosion
                for (let e = 0; e < 20; e++) {
                  const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3),
                    new THREE.MeshBasicMaterial({ color: Math.random() > 0.5 ? 0xFF4400 : 0xFFFF00 })
                  );
                  particle.position.copy(explosionPos);
                  scene.add(particle);
                  
                  const vel = new THREE.Vector3(
                    (Math.random() - 0.5) * 15,
                    Math.random() * 10,
                    (Math.random() - 0.5) * 15
                  );
                  let life = 0;
                  const timer = setInterval(() => {
                    particle.position.add(vel.clone().multiplyScalar(0.05));
                    vel.y -= 0.3;
                    life++;
                    if (life > 20) {
                      scene.remove(particle);
                      clearInterval(timer);
                    }
                  }, 50);
                }
                
                // Kill the creeper
                scene.remove(mob.model);
                hostileMobs.splice(i, 1);
                continue;
              }
            } else {
              // Normal attack
              mob.attackTimer = def.attackCooldown;
              
              if (def.isRanged) {
                // Skeleton shoots arrow
                const arrow = new THREE.Mesh(
                  new THREE.BoxGeometry(0.1, 0.1, 0.5),
                  new THREE.MeshBasicMaterial({ color: 0x8B4513 })
                );
                arrow.position.copy(mob.model.position);
                arrow.position.y += 1.5;
                
                const dir = camera.position.clone().sub(arrow.position).normalize();
                arrow.velocity = dir.multiplyScalar(25);
                arrow.lookAt(camera.position);
                
                scene.add(arrow);
                
                // Arrow update (separate from mob)
                const arrowUpdate = setInterval(() => {
                  arrow.position.add(arrow.velocity.clone().multiplyScalar(0.016));
                  arrow.velocity.y -= 0.3; // Gravity
                  
                  // Hit player?
                  if (arrow.position.distanceTo(camera.position) < 2) {
                    takeDamage(def.damage, 'skeleton');
                    scene.remove(arrow);
                    clearInterval(arrowUpdate);
                  }
                  
                  // Too far or hit ground?
                  if (arrow.position.y < 0 || arrow.position.distanceTo(mob.model.position) > 50) {
                    scene.remove(arrow);
                    clearInterval(arrowUpdate);
                  }
                }, 16);
              } else {
                // Melee attack
                takeDamage(def.damage, mob.type);
              }
            }
          }
        } else {
          // Wander
          mob.state = 'wander';
          if (mob.fuseStarted) {
            // Cancel creeper fuse if player moves away
            mob.fuseStarted = false;
            mob.fuseTimer = 0;
            mob.model.traverse(child => {
              if (child.material) child.material.emissive = new THREE.Color(0, 0, 0);
            });
          }
        }
        
        // Attack cooldown
        if (mob.attackTimer > 0) mob.attackTimer -= delta;
        
        // Movement
        const speed = mob.state === 'chase' ? mob.speed : mob.speed * 0.5;
        const moveDir = mob.targetDirection.clone().multiplyScalar(speed * delta);
        mob.model.position.add(moveDir);
        mob.model.position.y = 4; // Keep on ground (grass blocks at y=2 have top at y=4)
        
        // Face direction
        if (moveDir.length() > 0.001) {
          mob.model.rotation.y = Math.atan2(moveDir.x, moveDir.z);
        }
        
        // Walking animation
        if (mob.state === 'chase') {
          mob.model.position.y = 4 + Math.abs(Math.sin(Date.now() * 0.015)) * 0.15;
        }
      }
    }
    
    /**
     * Damage a hostile mob
     */
    function damageHostileMob(mob, amount) {
      if (mob.invulnerableTimer > 0) return;
      
      mob.health -= amount;
      mob.invulnerableTimer = 0.5;
      soundSystem.mobHurt();
      
      if (mob.health <= 0) {
        killHostileMob(mob);
      }
    }
    
    /**
     * Kill a hostile mob
     */
    function killHostileMob(mob) {
      soundSystem.mobDeath();
      
      const def = hostileMobTypes[mob.type];
      const deathPos = mob.model.position.clone();
      
      // Drop items
      def.drops.forEach(drop => {
        const count = drop.min + Math.floor(Math.random() * (drop.max - drop.min + 1));
        for (let i = 0; i < count; i++) {
          const dropPos = deathPos.clone();
          dropPos.x += (Math.random() - 0.5) * 2;
          dropPos.z += (Math.random() - 0.5) * 2;
          spawnDroppedItem(drop.type, dropPos);
        }
      });
      
      // Death particles (smoke for hostiles)
      for (let i = 0; i < 8; i++) {
        const smoke = new THREE.Mesh(
          new THREE.SphereGeometry(0.2),
          new THREE.MeshBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.7 })
        );
        smoke.position.copy(deathPos);
        smoke.position.y += 0.5;
        scene.add(smoke);
        
        const vel = new THREE.Vector3(
          (Math.random() - 0.5) * 2,
          Math.random() * 3,
          (Math.random() - 0.5) * 2
        );
        let life = 0;
        const timer = setInterval(() => {
          smoke.position.add(vel.clone().multiplyScalar(0.05));
          smoke.material.opacity -= 0.04;
          life++;
          if (life > 20) {
            scene.remove(smoke);
            clearInterval(timer);
          }
        }, 50);
      }
      
      scene.remove(mob.model);
      const idx = hostileMobs.indexOf(mob);
      if (idx > -1) hostileMobs.splice(idx, 1);
      
      // Score
      score += 5;
      scoreDisplay.textContent = score;
    }
    
    /**
     * Check if bullet hits hostile mob
     */
    function checkHostileMobHit(position, radius = 1.5) {
      for (const mob of hostileMobs) {
        const dist = position.distanceTo(mob.model.position);
        if (dist < radius) {
          return mob;
        }
      }
      return null;
    }
    // ===== END HOSTILE MOBS =====

    // ===== HELD ITEM DISPLAY (Minecraft-style) =====
    // When holding a block, show the block instead of the gun
    // When empty or no placeable item, show the gun
    
    let heldItemMesh = null;
    
    /**
     * Update the held item display based on selected slot
     * Minecraft-style: block replaces gun, shown in lower-right
     */
    function updateHeldItem() {
      // Remove current held item if exists
      if (heldItemMesh) {
        camera.remove(heldItemMesh);
        heldItemMesh = null;
      }
      
      // Get currently selected item
      const selectedItem = inventory.slots[inventory.selectedSlot];
      
      if (selectedItem) {
        // Hide gun, show held block
        gun.visible = false;
        
        const itemDef = itemTypes[selectedItem.type];
        const color = itemDef ? parseInt(itemDef.color.replace('#', '0x')) : 0xffffff;
        
        // Create Minecraft-style held block (larger, tilted, lower-right)
        heldItemMesh = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 0.4, 0.4),
          new THREE.MeshStandardMaterial({ color })
        );
        
        // Position: lower-right of screen, tilted like Minecraft
        heldItemMesh.position.set(0.5, -0.35, -0.7);
        heldItemMesh.rotation.set(-0.2, -0.8, 0.1); // Tilted toward camera
        camera.add(heldItemMesh);
      } else {
        // No item selected - show gun
        gun.visible = true;
      }
    }

    // Update selectSlot to also update held item
    const originalSelectSlot = selectSlot;
    selectSlot = function(slotIndex) {
      originalSelectSlot(slotIndex);
      updateHeldItem();
    };
    
    // Initialize held item display
    updateHeldItem();

    // ===== END HELD ITEM DISPLAY =====

    // ===== BLOCK PLACING (X key) =====
    
    /**
     * Place a block from inventory - Minecraft-style vertical stacking!
     * Blocks are placed on the face you're looking at (top, side, etc.)
     */
    function placeBlock() {
      const selectedItem = inventory.slots[inventory.selectedSlot];
      
      // Need an item to place
      if (!selectedItem || selectedItem.count <= 0) return;
      
      // Raycast to find placement position
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
      
      // Check intersection with ground and existing blocks (including ground blocks!)
      const intersects = raycaster.intersectObjects([ground, ...blocks, ...groundBlocks]);
      
      if (intersects.length > 0) {
        const hit = intersects[0];
        const point = hit.point;
        const normal = hit.face.normal.clone();
        
        // Check if we hit a ground block (grass, dirt, stone)
        const hitGroundBlock = groundBlocks.includes(hit.object);
        
        // Transform normal to world space if hitting a block
        if (hit.object !== ground) {
          normal.transformDirection(hit.object.matrixWorld);
        }
        
        // Grid size (block size)
        const gridSize = 4;
        
        // Calculate placement position based on hit normal (Minecraft-style!)
        let snapX, snapY, snapZ;
        
        if (hit.object === ground) {
          // Hit invisible ground plane - place block on top of where grass would be
          snapX = Math.round(point.x / gridSize) * gridSize;
          snapY = 6; // ON TOP of grass level (grass top at y=4, new block center at y=6)
          snapZ = Math.round(point.z / gridSize) * gridSize;
        } else if (hitGroundBlock) {
          // Hit a ground block (grass/dirt/stone) - place block adjacent to face
          const hitBlockPos = hit.object.position;
          
          // Round the normal to get axis-aligned direction
          const nx = Math.round(normal.x);
          const ny = Math.round(normal.y);
          const nz = Math.round(normal.z);
          
          // New block position is adjacent to hit block in the normal direction
          snapX = hitBlockPos.x + nx * gridSize;
          snapY = hitBlockPos.y + ny * gridSize;
          snapZ = hitBlockPos.z + nz * gridSize;
        } else {
          // Hit a placed block - place block adjacent to the face we hit
          const hitBlockPos = hit.object.position;
          
          // Round the normal to get axis-aligned direction
          const nx = Math.round(normal.x);
          const ny = Math.round(normal.y);
          const nz = Math.round(normal.z);
          
          // New block position is adjacent to hit block in the normal direction
          snapX = hitBlockPos.x + nx * gridSize;
          snapY = hitBlockPos.y + ny * gridSize;
          snapZ = hitBlockPos.z + nz * gridSize;
        }
        
        // Don't place too close to player (would get stuck!)
        const dx = snapX - camera.position.x;
        const dy = snapY - camera.position.y;
        const dz = snapZ - camera.position.z;
        const distToPlayer = Math.sqrt(dx * dx + dy * dy + dz * dz);
        if (distToPlayer < 3) return;
        
        // Don't place too far
        if (hit.distance > 20) return;
        
        // Check if a block already exists at this position
        for (const block of blocks) {
          const bx = block.position.x;
          const by = block.position.y;
          const bz = block.position.z;
          if (Math.abs(bx - snapX) < 1 && Math.abs(by - snapY) < 1 && Math.abs(bz - snapZ) < 1) {
            return; // Block already here!
          }
        }
        
        // Get color for placed block
        const itemDef = itemTypes[selectedItem.type];
        let blockColor = 0x888888;
        if (itemDef) {
          blockColor = parseInt(itemDef.color.replace('#', '0x'));
        }
        
        // Create the placed block with Y position!
        const placedBlock = makeBlock(snapX, snapZ, blockColor, snapY);
        placedBlock.userData.placedBy = 'player';
        placedBlock.userData.itemType = selectedItem.type;
        soundSystem.placeBlock(); // Thunk!
        
        // Consume item from inventory
        selectedItem.count--;
        if (selectedItem.count <= 0) {
          inventory.slots[inventory.selectedSlot] = null;
        }
        updateHotbarUI();
        updateHeldItem();
        
        // Placement effect
        const flash = new THREE.Mesh(
          new THREE.BoxGeometry(4.2, 4.2, 4.2),
          new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 })
        );
        flash.position.copy(placedBlock.position);
        scene.add(flash);
        setTimeout(() => scene.remove(flash), 100);
      }
    }

    // ===== END BLOCK PLACING =====

    // ===== GAME SETTINGS (expandable!) =====
    const settings = {
      aimSensitivity: 2,
      crosshairSize: 30,
      // Future settings can go here:
      // viewMode: 'first-person',
      // currentGun: 'pistol',
      // soundEnabled: true,
    };

    // ===== PLAYER STATS SYSTEM =====
    const player = {
      health: 20,
      maxHealth: 10, // 10 hearts (each heart = 2 HP)
      hunger: 20,
      maxHunger: 10, // 10 drumsticks (each = 2)
      lastY: 8, // For fall damage calculation
      fallDistance: 0,
      // Minecraft-style fall damage: track the GROUND HEIGHT you last stood on
      lastGroundY: 8, // The Y position of the last ground player stood on (standing on grass at y=4)
      isFalling: false,
    };

    // Initialize health & hunger bar UI
    const healthBar = document.getElementById('health-bar');
    const hungerBar = document.getElementById('hunger-bar');
    const damageOverlay = document.getElementById('damageOverlay');

    function updateHealthBar() {
      healthBar.innerHTML = '';
      for (let i = 0; i < player.maxHealth; i++) {
        const heart = document.createElement('div');
        heart.className = 'heart';
        const hp = player.health - (i * 2);
        if (hp <= 0) heart.classList.add('empty');
        else if (hp === 1) heart.classList.add('half');
        healthBar.appendChild(heart);
      }
    }

    function updateHungerBar() {
      hungerBar.innerHTML = '';
      for (let i = 0; i < player.maxHunger; i++) {
        const icon = document.createElement('div');
        icon.className = 'hunger-icon';
        const hunger = player.hunger - (i * 2);
        if (hunger <= 0) icon.classList.add('empty');
        else if (hunger === 1) icon.classList.add('half');
        hungerBar.appendChild(icon);
      }
    }

    // Death messages based on cause
    const deathMessages = {
      fall: 'Jax hit the ground too hard',
      starvation: 'Jax starved to death',
      zombie: 'Jax was slain by Zombie',
      skeleton: 'Jax was shot by Skeleton',
      spider: 'Jax was slain by Spider',
      creeper: 'Jax was blown up by Creeper',
      drowning: 'Jax drowned',
      void: 'Jax fell out of the world',
      ricochet: 'Jax was hit by own ricochet! üé±',
      generic: 'Jax died',
    };
    
    // Death screen elements
    const deathScreen = document.getElementById('deathScreen');
    const deathMessage = document.getElementById('deathMessage');
    const deathScoreEl = document.getElementById('deathScore');
    const respawnBtn = document.getElementById('respawnBtn');
    let isRespawning = false;
    let invulnerabilityTimer = 0;
    
    function takeDamage(amount, cause = 'generic') {
      // Invulnerability frames
      if (invulnerabilityTimer > 0) return;
      
      player.health = Math.max(0, player.health - amount);
      soundSystem.hurt(); // Oof!
      updateHealthBar();
      // Flash red overlay
      damageOverlay.style.background = 'rgba(255, 0, 0, 0.4)';
      setTimeout(() => damageOverlay.style.background = 'rgba(255, 0, 0, 0)', 200);
      
      if (player.health <= 0) {
        die(cause);
      }
    }
    
    function die(cause = 'generic') {
      soundSystem.death();
      
      // Drop all items at death location
      const deathPos = camera.position.clone();
      for (let i = 0; i < inventory.slots.length; i++) {
        const slot = inventory.slots[i];
        if (slot && slot.count > 0) {
          // Scatter items around death position
          for (let j = 0; j < slot.count; j++) {
            const scatterPos = deathPos.clone();
            scatterPos.x += (Math.random() - 0.5) * 4;
            scatterPos.z += (Math.random() - 0.5) * 4;
            spawnDroppedItem(slot.type, scatterPos);
          }
          inventory.slots[i] = null;
        }
      }
      updateHotbarUI();
      
      // Show death screen
      deathMessage.textContent = deathMessages[cause] || deathMessages.generic;
      deathScoreEl.textContent = score;
      deathScreen.classList.add('active');
      if (!TEST_MODE) controls.unlock();
    }
    
    function respawn() {
      // Reset player stats
      player.health = 20;
      player.hunger = 20;
      player.fallDistance = 0;
      player.lastGroundY = 8; // Reset fall tracking (standing on grass at y=4)
      player.isFalling = false;
      
      // Teleport to spawn point (standing on grass blocks at y=4, eyes at y=8)
      camera.position.set(0, 8, 10);
      velocity.x = 0;
      velocity.y = 0;
      velocity.z = 0;
      
      // Invulnerability frames (2 seconds)
      invulnerabilityTimer = 2;
      
      // Update UI
      updateHealthBar();
      updateHungerBar();
      updateHeldItem();
      
      // Hide death screen
      deathScreen.classList.remove('active');
      if (!TEST_MODE) {
        controls.lock();
      }
      
      soundSystem.levelUp(); // Respawn jingle!
    }
    
    respawnBtn.addEventListener('click', () => {
      soundSystem.buttonClick();
      respawn();
    });

    function heal(amount) {
      player.health = Math.min(20, player.health + amount);
      updateHealthBar();
    }

    function eat(foodValue) {
      const oldHunger = player.hunger;
      player.hunger = Math.min(20, player.hunger + foodValue);
      updateHungerBar();
      const actual = player.hunger - oldHunger;
      if (actual > 0 && typeof showNotification === 'function') {
        showNotification(`üçñ +${actual} Hunger!`, 1500);
      }
    }

    // Initialize bars
    updateHealthBar();
    updateHungerBar();

    // Hunger decreases over time
    setInterval(() => {
      const gameplayActive = TEST_MODE || controls.isLocked;
      if (!isPaused && gameplayActive) {
        player.hunger = Math.max(0, player.hunger - 1);
        updateHungerBar();
        
        // Regenerate health if hunger > 16 (like Minecraft)
        if (player.hunger > 16 && player.health < 20) {
          heal(1);
        }
        // Take damage if starving
        if (player.hunger <= 0) {
          takeDamage(1, 'starvation');
        }
      }
    }, 5000); // Every 5 seconds

    // ===== BLOCK HARDNESS SYSTEM =====
    // Different blocks take different amounts of hits to break
    const blockHardness = {
      grass: 2,  // Grass breaks like dirt
      dirt: 2,
      wood: 4,
      stone: 6,
      leaves: 1,
      treasure: 8,
      default: 3,
    };

    // Track block damage (for mining)
    const blockDamageMap = new Map(); // mesh -> { damage: number, crackMesh: THREE.Mesh }

    // Create crack texture for damaged blocks
    function createCrackOverlay(block, damagePercent) {
      // Remove existing crack if any
      const existing = blockDamageMap.get(block);
      if (existing && existing.crackMesh) {
        scene.remove(existing.crackMesh);
      }
      
      // Create crack overlay (wireframe that gets denser)
      const crackGeo = block.geometry.clone();
      const crackMat = new THREE.MeshBasicMaterial({
        color: 0x000000,
        wireframe: true,
        transparent: true,
        opacity: damagePercent * 0.8,
      });
      const crackMesh = new THREE.Mesh(crackGeo, crackMat);
      crackMesh.position.copy(block.position);
      crackMesh.scale.multiplyScalar(1.01); // Slightly larger to prevent z-fighting
      scene.add(crackMesh);
      
      return crackMesh;
    }

    // ===== DAY/NIGHT CYCLE =====
    let timeOfDay = 0.4; // 0-1, 0 = midnight, 0.25 = sunrise, 0.5 = noon, 0.75 = sunset (start at day!)
    let dayLength = 120; // 2 minutes per full day/night cycle (can be changed in settings)
    let daySpeed = 1; // Multiplier for day speed (0 = paused, 0.5 = slow, 1 = normal, 2 = fast)

    function updateDayNightCycle(delta) {
      // Update time based on speed setting
      timeOfDay += (delta / dayLength) * daySpeed;
      if (timeOfDay > 1) timeOfDay -= 1;
      if (timeOfDay < 0) timeOfDay += 1;
      
      // ===== ANIMATE SUN & MOON POSITIONS =====
      // Sun angle: 0 at midnight (below), 0.5 at noon (above)
      // timeOfDay 0.25 = sunrise (east), 0.5 = noon (top), 0.75 = sunset (west)
      const sunAngle = (timeOfDay - 0.25) * Math.PI * 2; // Full rotation
      // Fixed: sin for Y (height), cos for X (horizontal position)
      const sunX = Math.cos(sunAngle) * SKY_RADIUS;
      const sunY = Math.sin(sunAngle) * SKY_RADIUS;
      
      // Position sun relative to camera (follows player)
      sunMesh.position.set(
        camera.position.x + sunX,
        sunY,
        camera.position.z - 50
      );
      
      // Moon is opposite the sun
      moonMesh.position.set(
        camera.position.x - sunX,
        -sunY,
        camera.position.z - 50
      );
      
      // Spin the moon for a sparkly effect!
      moonMesh.rotation.y += delta * 0.2;
      
      // Fade sun/moon based on position (below horizon = invisible)
      sunMesh.visible = sunY > -20;
      moonMesh.visible = -sunY > -20;
      
      // Adjust sun color based on time (orange at sunrise/sunset, yellow at noon)
      if (timeOfDay > 0.2 && timeOfDay < 0.4) {
        // Sunrise - orange
        sunMesh.material.color.setHex(0xff8844);
        sunGlow.material.color.setHex(0xff6600);
      } else if (timeOfDay > 0.7 && timeOfDay < 0.9) {
        // Sunset - orange/red
        sunMesh.material.color.setHex(0xff6633);
        sunGlow.material.color.setHex(0xff4400);
      } else {
        // Daytime - bright yellow
        sunMesh.material.color.setHex(0xffdd44);
        sunGlow.material.color.setHex(0xffaa00);
      }
      
      // Calculate sky color based on time
      let skyColor, fogColor, sunIntensity;
      
      if (timeOfDay < 0.2) {
        // Night (0-0.2)
        skyColor = new THREE.Color(0x0a0a20);
        fogColor = new THREE.Color(0x0a0a20);
        sunIntensity = 0.1;
      } else if (timeOfDay < 0.3) {
        // Sunrise (0.2-0.3)
        const t = (timeOfDay - 0.2) / 0.1;
        skyColor = new THREE.Color(0x0a0a20).lerp(new THREE.Color(0xff8844), t);
        fogColor = new THREE.Color(0x0a0a20).lerp(new THREE.Color(0xff8844), t);
        sunIntensity = 0.1 + t * 0.5;
      } else if (timeOfDay < 0.4) {
        // Morning (0.3-0.4)
        const t = (timeOfDay - 0.3) / 0.1;
        skyColor = new THREE.Color(0xff8844).lerp(new THREE.Color(0x87ceeb), t);
        fogColor = new THREE.Color(0xff8844).lerp(new THREE.Color(0x87ceeb), t);
        sunIntensity = 0.6 + t * 0.4;
      } else if (timeOfDay < 0.7) {
        // Day (0.4-0.7)
        skyColor = new THREE.Color(0x87ceeb);
        fogColor = new THREE.Color(0x87ceeb);
        sunIntensity = 1.0;
      } else if (timeOfDay < 0.8) {
        // Sunset (0.7-0.8)
        const t = (timeOfDay - 0.7) / 0.1;
        skyColor = new THREE.Color(0x87ceeb).lerp(new THREE.Color(0xff6633), t);
        fogColor = new THREE.Color(0x87ceeb).lerp(new THREE.Color(0xff6633), t);
        sunIntensity = 1.0 - t * 0.4;
      } else if (timeOfDay < 0.9) {
        // Dusk (0.8-0.9)
        const t = (timeOfDay - 0.8) / 0.1;
        skyColor = new THREE.Color(0xff6633).lerp(new THREE.Color(0x1a1a40), t);
        fogColor = new THREE.Color(0xff6633).lerp(new THREE.Color(0x1a1a40), t);
        sunIntensity = 0.6 - t * 0.4;
      } else {
        // Night (0.9-1.0)
        const t = (timeOfDay - 0.9) / 0.1;
        skyColor = new THREE.Color(0x1a1a40).lerp(new THREE.Color(0x0a0a20), t);
        fogColor = new THREE.Color(0x1a1a40).lerp(new THREE.Color(0x0a0a20), t);
        sunIntensity = 0.2 - t * 0.1;
      }
      
      scene.background = skyColor;
      scene.fog.color = fogColor;
      sun.intensity = sunIntensity;
      
      // Update time display in settings if menu is open
      if (isPaused && timeValueEl) {
        const hours = Math.floor(timeOfDay * 24);
        const mins = Math.floor((timeOfDay * 24 * 60) % 60);
        timeValueEl.textContent = `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
      }
    }

    // ===== CRAFTING SYSTEM =====
    const recipes = [
      // Basic materials
      { name: 'Planks', result: 'planks', resultCount: 4, ingredients: { wood: 1 }, icon: 'üü´' },
      { name: 'Sticks', result: 'stick', resultCount: 4, ingredients: { planks: 2 }, icon: 'ü•¢' },
      { name: 'Torch', result: 'torch', resultCount: 4, ingredients: { stick: 1, coal: 1 }, icon: 'üî¶' },
      { name: 'Cooked Meat', result: 'food', resultCount: 1, ingredients: { wood: 2 }, icon: 'üçñ' },
      // Wooden tools
      { name: 'Wooden Pickaxe', result: 'wooden_pickaxe', resultCount: 1, ingredients: { planks: 3, stick: 2 }, icon: '‚õèÔ∏è' },
      { name: 'Wooden Axe', result: 'wooden_axe', resultCount: 1, ingredients: { planks: 3, stick: 2 }, icon: 'ü™ì' },
      { name: 'Wooden Shovel', result: 'wooden_shovel', resultCount: 1, ingredients: { planks: 1, stick: 2 }, icon: 'ü•Ñ' },
      { name: 'Wooden Sword', result: 'wooden_sword', resultCount: 1, ingredients: { planks: 2, stick: 1 }, icon: 'üó°Ô∏è' },
      // Stone tools
      { name: 'Stone Pickaxe', result: 'stone_pickaxe', resultCount: 1, ingredients: { cobblestone: 3, stick: 2 }, icon: '‚õèÔ∏è' },
      { name: 'Stone Axe', result: 'stone_axe', resultCount: 1, ingredients: { cobblestone: 3, stick: 2 }, icon: 'ü™ì' },
      { name: 'Stone Shovel', result: 'stone_shovel', resultCount: 1, ingredients: { cobblestone: 1, stick: 2 }, icon: 'ü•Ñ' },
      { name: 'Stone Sword', result: 'stone_sword', resultCount: 1, ingredients: { cobblestone: 2, stick: 1 }, icon: 'üó°Ô∏è' },
      // Iron tools
      { name: 'Iron Pickaxe', result: 'iron_pickaxe', resultCount: 1, ingredients: { iron_ingot: 3, stick: 2 }, icon: '‚õèÔ∏è' },
      { name: 'Iron Axe', result: 'iron_axe', resultCount: 1, ingredients: { iron_ingot: 3, stick: 2 }, icon: 'ü™ì' },
      { name: 'Iron Shovel', result: 'iron_shovel', resultCount: 1, ingredients: { iron_ingot: 1, stick: 2 }, icon: 'ü•Ñ' },
      { name: 'Iron Sword', result: 'iron_sword', resultCount: 1, ingredients: { iron_ingot: 2, stick: 1 }, icon: 'üó°Ô∏è' },
      // Diamond tools
      { name: 'Diamond Pickaxe', result: 'diamond_pickaxe', resultCount: 1, ingredients: { diamond: 3, stick: 2 }, icon: '‚õèÔ∏è' },
      { name: 'Diamond Axe', result: 'diamond_axe', resultCount: 1, ingredients: { diamond: 3, stick: 2 }, icon: 'ü™ì' },
      { name: 'Diamond Shovel', result: 'diamond_shovel', resultCount: 1, ingredients: { diamond: 1, stick: 2 }, icon: 'ü•Ñ' },
      { name: 'Diamond Sword', result: 'diamond_sword', resultCount: 1, ingredients: { diamond: 2, stick: 1 }, icon: 'üó°Ô∏è' },
      // Smelting materials  
      { name: 'Golden Block', result: 'treasure', resultCount: 1, ingredients: { gold_ingot: 9 }, icon: 'üèÜ' },
      // Furnace
      { name: 'Furnace', result: 'furnace', resultCount: 1, ingredients: { cobblestone: 8 }, icon: 'üî•' },
    ];

    // Add food to itemTypes (generic craftable food)
    itemTypes.food = { name: 'Cooked Meat', color: 0xcc6633, icon: 'üçñ', isEdible: true, hungerValue: 6 };
    itemTypes.torch = { name: 'Torch', color: 0xffaa00, icon: 'üî¶' };
    itemColors.food = 0xcc6633;
    itemColors.torch = 0xffaa00;

    const craftingMenu = document.getElementById('craftingMenu');
    const recipeList = document.getElementById('recipeList');
    const closeCraftingBtn = document.getElementById('closeCraftingBtn');
    let isCrafting = false;

    function canCraft(recipe) {
      for (const [item, count] of Object.entries(recipe.ingredients)) {
        const total = inventory.slots.reduce((sum, slot) => 
          slot && slot.type === item ? sum + slot.count : sum, 0);
        if (total < count) return false;
      }
      return true;
    }

    function craft(recipe) {
      if (!canCraft(recipe)) return false;
      
      // Remove ingredients
      for (const [item, count] of Object.entries(recipe.ingredients)) {
        let remaining = count;
        for (let i = 0; i < inventory.slots.length && remaining > 0; i++) {
          const slot = inventory.slots[i];
          if (slot && slot.type === item) {
            const remove = Math.min(slot.count, remaining);
            slot.count -= remove;
            remaining -= remove;
            if (slot.count <= 0) inventory.slots[i] = null;
          }
        }
      }
      
      // Add result
      addToInventory(recipe.result, recipe.resultCount);
      soundSystem.craftSuccess(); // Ding!
      updateHotbarUI();
      updateRecipeList();
      return true;
    }

    function updateRecipeList() {
      recipeList.innerHTML = '';
      recipes.forEach((recipe, index) => {
        const canMake = canCraft(recipe);
        const div = document.createElement('div');
        div.className = `recipe-item ${canMake ? 'can-craft' : 'cannot-craft'}`;
        
        const ingredients = Object.entries(recipe.ingredients)
          .map(([item, count]) => `${count}x ${item}`)
          .join(' + ');
        
        div.innerHTML = `
          <div>
            <div class="recipe-result">${recipe.icon} ${recipe.name} (x${recipe.resultCount})</div>
            <div class="recipe-ingredients">${ingredients}</div>
          </div>
          <div style="font-size: 24px">${canMake ? '‚úÖ' : '‚ùå'}</div>
        `;
        
        div.onclick = () => craft(recipe);
        recipeList.appendChild(div);
      });
    }

    function toggleCrafting() {
      isCrafting = !isCrafting;
      if (isCrafting) {
        craftingMenu.classList.add('active');
        if (!TEST_MODE) controls.unlock();
        updateRecipeList();
        soundSystem.menuOpen();
      } else {
        craftingMenu.classList.remove('active');
        if (!isPaused && !TEST_MODE) controls.lock();
        soundSystem.menuClose();
      }
    }

    closeCraftingBtn.onclick = toggleCrafting;

    // ===== FURNACE SYSTEM =====
    const furnaceMenu = document.getElementById('furnaceMenu');
    const furnaceInput = document.getElementById('furnaceInput');
    const furnaceOutput = document.getElementById('furnaceOutput');
    const furnaceFuel = document.getElementById('furnaceFuel');
    const smeltProgress = document.getElementById('smeltProgress');
    const fuelProgress = document.getElementById('fuelProgress');
    const closeFurnaceBtn = document.getElementById('closeFurnaceBtn');
    const furnaceArrow = document.getElementById('furnaceArrow');
    
    let isFurnaceOpen = false;
    
    // Furnace state
    const furnaceState = {
      input: null,      // { type, count }
      fuel: null,       // { type, count }
      output: null,     // { type, count }
      smeltProgress: 0, // 0-1
      fuelRemaining: 0, // seconds
      maxFuel: 0,       // for fuel bar display
      isSmelting: false,
    };
    
    // Smelting recipes
    const smeltingRecipes = {
      iron_ore: { output: 'iron_ingot', time: 10 },
      gold_ore: { output: 'gold_ingot', time: 10 },
      raw_porkchop: { output: 'cooked_porkchop', time: 10 },
      raw_beef: { output: 'cooked_beef', time: 10 },
      raw_chicken: { output: 'cooked_chicken', time: 10 },
      raw_mutton: { output: 'cooked_mutton', time: 10 },
      cobblestone: { output: 'stone', time: 10 },
    };
    
    // Fuel values (burn time in seconds)
    const fuelValues = {
      coal: 80,        // 8 items
      wood: 15,        // 1.5 items
      planks: 15,      // 1.5 items
      stick: 5,        // 0.5 items
    };
    
    function toggleFurnace() {
      isFurnaceOpen = !isFurnaceOpen;
      if (isFurnaceOpen) {
        furnaceMenu.classList.add('active');
        if (!TEST_MODE) controls.unlock();
        updateFurnaceUI();
        soundSystem.menuOpen();
      } else {
        furnaceMenu.classList.remove('active');
        if (!isPaused && !isCrafting && !TEST_MODE) controls.lock();
        soundSystem.menuClose();
      }
    }
    
    function updateFurnaceUI() {
      // Input slot
      furnaceInput.innerHTML = '<span class="slot-label">INPUT</span>';
      if (furnaceState.input) {
        const def = itemTypes[furnaceState.input.type];
        furnaceInput.innerHTML += `<div style="font-size:32px">${def?.icon || '?'}</div><span style="position:absolute;bottom:2px;right:4px">${furnaceState.input.count}</span>`;
        furnaceInput.classList.add('has-item');
      } else {
        furnaceInput.classList.remove('has-item');
      }
      
      // Fuel slot
      furnaceFuel.innerHTML = '<span class="slot-label">FUEL</span>';
      if (furnaceState.fuel) {
        const def = itemTypes[furnaceState.fuel.type];
        furnaceFuel.innerHTML += `<div style="font-size:32px">${def?.icon || '?'}</div><span style="position:absolute;bottom:2px;right:4px">${furnaceState.fuel.count}</span>`;
        furnaceFuel.classList.add('has-item');
      } else {
        furnaceFuel.classList.remove('has-item');
      }
      
      // Output slot
      furnaceOutput.innerHTML = '<span class="slot-label">OUTPUT</span>';
      if (furnaceState.output) {
        const def = itemTypes[furnaceState.output.type];
        furnaceOutput.innerHTML += `<div style="font-size:32px">${def?.icon || '?'}</div><span style="position:absolute;bottom:2px;right:4px">${furnaceState.output.count}</span>`;
        furnaceOutput.classList.add('has-item');
      } else {
        furnaceOutput.classList.remove('has-item');
      }
      
      // Progress bars
      smeltProgress.style.width = `${furnaceState.smeltProgress * 100}%`;
      fuelProgress.style.width = furnaceState.maxFuel > 0 ? `${(furnaceState.fuelRemaining / furnaceState.maxFuel) * 100}%` : '0%';
      
      // Arrow color
      furnaceArrow.classList.toggle('active', furnaceState.isSmelting);
    }
    
    // Click handlers for furnace slots
    furnaceInput.onclick = () => {
      if (furnaceState.input) {
        // Take item back to inventory
        if (addToInventory(furnaceState.input.type, furnaceState.input.count)) {
          furnaceState.input = null;
          soundSystem.itemPickup();
          updateFurnaceUI();
        }
      } else {
        // Find smeltable item in inventory
        for (let i = 0; i < inventory.slots.length; i++) {
          const slot = inventory.slots[i];
          if (slot && smeltingRecipes[slot.type]) {
            furnaceState.input = { type: slot.type, count: slot.count };
            inventory.slots[i] = null;
            updateHotbarUI();
            soundSystem.placeBlock();
            updateFurnaceUI();
            break;
          }
        }
      }
    };
    
    furnaceFuel.onclick = () => {
      if (furnaceState.fuel) {
        // Take fuel back
        if (addToInventory(furnaceState.fuel.type, furnaceState.fuel.count)) {
          furnaceState.fuel = null;
          soundSystem.itemPickup();
          updateFurnaceUI();
        }
      } else {
        // Find fuel in inventory
        for (let i = 0; i < inventory.slots.length; i++) {
          const slot = inventory.slots[i];
          if (slot && fuelValues[slot.type]) {
            furnaceState.fuel = { type: slot.type, count: slot.count };
            inventory.slots[i] = null;
            updateHotbarUI();
            soundSystem.placeBlock();
            updateFurnaceUI();
            break;
          }
        }
      }
    };
    
    furnaceOutput.onclick = () => {
      if (furnaceState.output) {
        // Take output to inventory
        if (addToInventory(furnaceState.output.type, furnaceState.output.count)) {
          furnaceState.output = null;
          soundSystem.itemPickup();
          soundSystem.craftSuccess();
          updateFurnaceUI();
        }
      }
    };
    
    closeFurnaceBtn.onclick = toggleFurnace;
    
    // Furnace update (called in animation loop)
    function updateFurnace(delta) {
      if (!furnaceState.input) {
        furnaceState.isSmelting = false;
        furnaceState.smeltProgress = 0;
        return;
      }
      
      const recipe = smeltingRecipes[furnaceState.input.type];
      if (!recipe) {
        furnaceState.isSmelting = false;
        return;
      }
      
      // Check if output slot can accept result
      if (furnaceState.output && 
          (furnaceState.output.type !== recipe.output || furnaceState.output.count >= 64)) {
        furnaceState.isSmelting = false;
        return;
      }
      
      // Need fuel to smelt
      if (furnaceState.fuelRemaining <= 0) {
        if (furnaceState.fuel && fuelValues[furnaceState.fuel.type]) {
          // Consume fuel
          furnaceState.fuelRemaining = fuelValues[furnaceState.fuel.type];
          furnaceState.maxFuel = furnaceState.fuelRemaining;
          furnaceState.fuel.count--;
          if (furnaceState.fuel.count <= 0) {
            furnaceState.fuel = null;
          }
          furnaceState.isSmelting = true;
        } else {
          // No fuel - regress progress
          furnaceState.isSmelting = false;
          furnaceState.smeltProgress = Math.max(0, furnaceState.smeltProgress - delta / recipe.time / 2);
        }
      }
      
      // Smelt if we have fuel
      if (furnaceState.fuelRemaining > 0) {
        furnaceState.fuelRemaining -= delta;
        furnaceState.isSmelting = true;
        furnaceState.smeltProgress += delta / recipe.time;
        
        // Complete smelting
        if (furnaceState.smeltProgress >= 1) {
          furnaceState.smeltProgress = 0;
          
          // Add to output
          if (furnaceState.output) {
            furnaceState.output.count++;
          } else {
            furnaceState.output = { type: recipe.output, count: 1 };
          }
          
          // Remove from input
          furnaceState.input.count--;
          if (furnaceState.input.count <= 0) {
            furnaceState.input = null;
          }
          
          soundSystem.craftSuccess();
        }
      }
      
      // Update UI if furnace is open
      if (isFurnaceOpen) {
        updateFurnaceUI();
      }
    }
    // ===== END FURNACE SYSTEM =====

    // ===== MINING SYSTEM =====
    let isMining = false;
    let mineTarget = null;
    let mineAccumulator = 0;
    const baseMineRate = 1; // Base damage per second (fist)
    
    /**
     * Get the mining speed based on equipped tool
     */
    function getMiningSpeed() {
      const selectedItem = inventory.slots[inventory.selectedSlot];
      if (!selectedItem) return baseMineRate;
      
      const itemDef = itemTypes[selectedItem.type];
      if (!itemDef || !itemDef.isTool) return baseMineRate;
      
      return itemDef.miningSpeed || baseMineRate;
    }
    
    /**
     * Get the attack damage based on equipped tool
     */
    function getAttackDamage() {
      const selectedItem = inventory.slots[inventory.selectedSlot];
      if (!selectedItem) return 1; // Fist = 1 damage
      
      const itemDef = itemTypes[selectedItem.type];
      if (!itemDef || !itemDef.isTool) return 1;
      
      return itemDef.damage || 1;
    }
    
    /**
     * Use durability on the equipped tool
     */
    function useToolDurability() {
      const selectedItem = inventory.slots[inventory.selectedSlot];
      if (!selectedItem) return;
      
      const itemDef = itemTypes[selectedItem.type];
      if (!itemDef || !itemDef.isTool) return;
      
      // Initialize durability if not set
      if (selectedItem.durability === undefined) {
        selectedItem.durability = itemDef.durability;
      }
      
      selectedItem.durability--;
      
      // Tool breaks!
      if (selectedItem.durability <= 0) {
        soundSystem.breakBlock(); // Tool break sound
        inventory.slots[inventory.selectedSlot] = null;
        updateHotbarUI();
        updateHeldItem();
        
        // Show message
        const popup = document.createElement('div');
        popup.className = 'score-popup';
        popup.textContent = `${itemDef.name} broke!`;
        popup.style.left = '50%';
        popup.style.top = '40%';
        popup.style.color = '#ff6666';
        document.body.appendChild(popup);
        setTimeout(() => popup.remove(), 2000);
      } else {
        updateHotbarUI(); // Update durability display
      }
    }

    // Get target block from raycaster
    function getMineTarget() {
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
      
      // Check passive mobs first (melee attack)
      for (const mob of mobs) {
        const mobPos = mob.model.position.clone();
        mobPos.y += 0.5; // Aim at center of mob
        const dirToMob = mobPos.clone().sub(camera.position);
        const camDir = new THREE.Vector3();
        camera.getWorldDirection(camDir);
        
        // Check if looking at mob and close enough
        const dot = dirToMob.normalize().dot(camDir);
        const dist = camera.position.distanceTo(mobPos);
        if (dot > 0.9 && dist < 5) {
          return { type: 'mob', mob: mob, hardness: 0.5, isHostile: false };
        }
      }
      
      // Check hostile mobs (melee attack)
      for (const mob of hostileMobs) {
        const mobPos = mob.model.position.clone();
        mobPos.y += 0.8; // Aim at center of hostile mob (taller)
        const dirToMob = mobPos.clone().sub(camera.position);
        const camDir = new THREE.Vector3();
        camera.getWorldDirection(camDir);
        
        const dot = dirToMob.normalize().dot(camDir);
        const dist = camera.position.distanceTo(mobPos);
        if (dot > 0.9 && dist < 5) {
          return { type: 'mob', mob: mob, hardness: 0.5, isHostile: true };
        }
      }
      
      // Check blocks
      const blockHits = raycaster.intersectObjects(blocks);
      if (blockHits.length > 0 && blockHits[0].distance < 8) {
        return { type: 'block', object: blockHits[0].object, hardness: blockHardness.default };
      }
      
      // Check ground blocks (grass/dirt/stone)
      const groundHits = raycaster.intersectObjects(groundBlocks);
      if (groundHits.length > 0 && groundHits[0].distance < 8) {
        const gb = groundHits[0].object;
        const gbType = gb.userData.type || 'dirt';
        const hardness = blockHardness[gbType] || blockHardness.dirt;
        return { type: 'ground', object: gb, hardness: hardness };
      }
      
      // Check if aiming at invisible ground plane (generates blocks when digging)
      const groundPlaneHits = raycaster.intersectObject(ground);
      if (groundPlaneHits.length > 0 && groundPlaneHits[0].distance < 8) {
        const hitPoint = groundPlaneHits[0].point;
        // Generate ground blocks at this location
        ensureGroundBlocksNear(hitPoint.x, hitPoint.z);
        // Now try to get the generated block
        const newGroundHits = raycaster.intersectObjects(groundBlocks);
        if (newGroundHits.length > 0 && newGroundHits[0].distance < 8) {
          const gb = newGroundHits[0].object;
          const gbType = gb.userData.type || 'dirt';
          const hardness = blockHardness[gbType] || blockHardness.dirt;
          return { type: 'ground', object: gb, hardness: hardness };
        }
      }
      
      // Check tree parts
      const treeHits = raycaster.intersectObjects(treeParts.filter(p => p.parent));
      if (treeHits.length > 0 && treeHits[0].distance < 8) {
        const part = treeHits[0].object;
        const type = part.userData.type === 'leaf' ? 'leaves' : 'wood';
        return { type: 'tree', object: part, hardness: blockHardness[type] };
      }
      
      // Check cave parts
      const caveHits = raycaster.intersectObjects(caveParts.filter(p => p.parent));
      if (caveHits.length > 0 && caveHits[0].distance < 8) {
        const part = caveHits[0].object;
        // Determine hardness based on block type
        let hardnessType = 'stone';
        if (part.userData.type === 'treasure') hardnessType = 'treasure';
        else if (part.userData.oreType) {
          // Ores are harder than regular stone
          const oreHardness = {
            'coal_ore': 3,
            'iron_ore': 4,
            'gold_ore': 4,
            'diamond_ore': 5,
          };
          return { type: 'cave', object: part, hardness: oreHardness[part.userData.oreType] || 3 };
        }
        return { type: 'cave', object: part, hardness: blockHardness[hardnessType] };
      }
      
      return null;
    }

    function updateMining(delta) {
      if (!isMining || isPaused || isCrafting) return;
      
      const target = getMineTarget();
      if (!target) {
        mineTarget = null;
        mineAccumulator = 0;
        return;
      }
      
      // Handle mob attacks separately (instant damage, no mining)
      if (target.type === 'mob') {
        // Attack cooldown (can only attack every 0.5 seconds)
        mineAccumulator += delta;
        if (mineAccumulator >= 0.5) {
          mineAccumulator = 0;
          playSwingAnimation(); // Swing when attacking!
          const damage = getAttackDamage();
          useToolDurability(); // Attacking also uses durability
          if (target.isHostile) {
            damageHostileMob(target.mob, damage);
          } else {
            damageMob(target.mob, damage);
          }
        }
        return;
      }
      
      // If target changed, reset
      if (mineTarget !== target.object) {
        // Clear old target's damage
        if (mineTarget && blockDamageMap.has(mineTarget)) {
          const data = blockDamageMap.get(mineTarget);
          if (data.crackMesh) scene.remove(data.crackMesh);
          blockDamageMap.delete(mineTarget);
        }
        mineTarget = target.object;
        mineAccumulator = 0;
      }
      
      // Accumulate mining damage (speed based on tool)
      const prevAccumulator = mineAccumulator;
      const currentMineRate = getMiningSpeed();
      mineAccumulator += currentMineRate * delta;
      
      // Play mining hit sound every 0.3 seconds of mining
      if (Math.floor(mineAccumulator / 0.3) > Math.floor(prevAccumulator / 0.3)) {
        soundSystem.mineHit();
        playSwingAnimation(); // Swing the pickaxe!
      }
      
      // Get or create damage data
      let damageData = blockDamageMap.get(mineTarget);
      if (!damageData) {
        damageData = { damage: 0, crackMesh: null };
        blockDamageMap.set(mineTarget, damageData);
      }
      
      damageData.damage = mineAccumulator;
      const damagePercent = damageData.damage / target.hardness;
      
      // Update crack overlay
      damageData.crackMesh = createCrackOverlay(mineTarget, damagePercent);
      blockDamageMap.set(mineTarget, damageData);
      
      // Check if block is broken
      if (damageData.damage >= target.hardness) {
        breakBlock(target);
        if (damageData.crackMesh) scene.remove(damageData.crackMesh);
        blockDamageMap.delete(mineTarget);
        mineTarget = null;
        mineAccumulator = 0;
      }
    }

    function breakBlock(target) {
      soundSystem.breakBlock(); // Crack!
      useToolDurability(); // Use tool durability
      
      const obj = target.object;
      const worldPos = new THREE.Vector3();
      obj.getWorldPosition(worldPos);
      
      // Spawn particles
      const particleColor = obj.material.color ? obj.material.color.getHex() : 0x888888;
      for (let s = 0; s < 6; s++) {
        const spark = new THREE.Mesh(
          new THREE.SphereGeometry(0.2),
          new THREE.MeshBasicMaterial({ color: particleColor })
        );
        spark.position.copy(worldPos);
        scene.add(spark);
        
        const sparkVel = new THREE.Vector3(
          (Math.random() - 0.5) * 10,
          Math.random() * 8,
          (Math.random() - 0.5) * 10
        );
        spark.userData.vel = sparkVel;
        spark.userData.life = 0;
        
        const sparkTimer = setInterval(() => {
          spark.position.add(spark.userData.vel.clone().multiplyScalar(0.05));
          spark.userData.vel.y -= 0.4;
          spark.userData.life++;
          if (spark.userData.life > 15) {
            scene.remove(spark);
            clearInterval(sparkTimer);
          }
        }, 50);
      }
      
      // Drop item based on type
      let dropType = 'cobblestone';
      if (target.type === 'block') {
        dropType = 'cobblestone'; // Regular blocks drop cobblestone
        spawnDroppedItem(dropType, worldPos, obj.material.color.getHex());
        scene.remove(obj);
        const idx = blocks.indexOf(obj);
        if (idx > -1) blocks.splice(idx, 1);
      } else if (target.type === 'tree') {
        dropType = obj.userData.type === 'leaf' ? 'leaves' : 'wood';
        spawnDroppedItem(dropType, worldPos);
        const parent = obj.userData.parentTree;
        if (parent) parent.remove(obj);
        const idx = treeParts.indexOf(obj);
        if (idx > -1) treeParts.splice(idx, 1);
      } else if (target.type === 'ground') {
        // Ground blocks drop their type (grass drops grass, dirt drops dirt, stone drops cobblestone)
        const groundType = obj.userData.type || 'dirt';
        if (groundType === 'grass') {
          dropType = 'dirt'; // Grass drops dirt (like Minecraft)
        } else if (groundType === 'dirt') {
          dropType = 'dirt';
        } else {
          dropType = 'cobblestone'; // Stone drops cobblestone
        }
        spawnDroppedItem(dropType, worldPos);
        
        // Track this position as "dug out" so it doesn't regenerate
        const gridX = Math.round(worldPos.x / GROUND_BLOCK_SIZE) * GROUND_BLOCK_SIZE;
        const gridY = Math.round(worldPos.y / GROUND_BLOCK_SIZE) * GROUND_BLOCK_SIZE;
        const gridZ = Math.round(worldPos.z / GROUND_BLOCK_SIZE) * GROUND_BLOCK_SIZE;
        const posKey = `${gridX},${gridY},${gridZ}`;
        dugOutPositions.add(posKey);
        
        scene.remove(obj);
        const idx = groundBlocks.indexOf(obj);
        if (idx > -1) groundBlocks.splice(idx, 1);
        
        // Generate blocks in adjacent columns (not at this position - it's dug out!)
        // This ensures there's terrain to dig into nearby
        ensureGroundBlocksNear(worldPos.x + GROUND_BLOCK_SIZE, worldPos.z);
        ensureGroundBlocksNear(worldPos.x - GROUND_BLOCK_SIZE, worldPos.z);
        ensureGroundBlocksNear(worldPos.x, worldPos.z + GROUND_BLOCK_SIZE);
        ensureGroundBlocksNear(worldPos.x, worldPos.z - GROUND_BLOCK_SIZE);
      } else if (target.type === 'cave') {
        // Check if it's an ore block
        const oreType = obj.userData.oreType;
        if (oreType) {
          // Drop based on ore type
          switch (oreType) {
            case 'coal_ore': dropType = 'coal'; break;
            case 'iron_ore': dropType = 'iron_ore'; break;
            case 'gold_ore': dropType = 'gold_ore'; break;
            case 'diamond_ore': dropType = 'diamond'; break;
            default: dropType = 'cobblestone';
          }
        } else if (obj.userData.type === 'treasure') {
          dropType = 'treasure';
        } else {
          dropType = 'cobblestone'; // Stone blocks drop cobblestone
        }
        spawnDroppedItem(dropType, worldPos);
        const parent = obj.userData.parentCave;
        if (parent) parent.remove(obj);
        const idx = caveParts.indexOf(obj);
        if (idx > -1) caveParts.splice(idx, 1);
      }
      
      // Score
      const points = dropType === 'treasure' ? 5 : 1;
      score += points;
      scoreDisplay.textContent = score;
      showScorePopup(worldPos);
    }

    // ===== TOOL DURABILITY =====
    // For simplicity, we'll track durability on the selected item
    // This can be expanded later with proper tool items

    // Pause menu elements
    const pauseMenu = document.getElementById('pauseMenu');
    const resumeBtn = document.getElementById('resumeBtn');
    const sensitivitySlider = document.getElementById('sensitivitySlider');
    const crosshairSlider = document.getElementById('crosshairSlider');
    const sensValue = document.getElementById('sensValue');
    const crosshairValue = document.getElementById('crosshairValue');
    const crosshairEl = document.getElementById('crosshair');
    
    // Time settings elements
    const timeSlider = document.getElementById('timeSlider');
    const speedSlider = document.getElementById('speedSlider');
    const timeValueEl = document.getElementById('timeValue');
    const speedValueEl = document.getElementById('speedValue');
    const setDayBtn = document.getElementById('setDayBtn');
    const setNightBtn = document.getElementById('setNightBtn');
    
    // Sound settings elements
    const masterVolSlider = document.getElementById('masterVolSlider');
    const blocksVolSlider = document.getElementById('blocksVolSlider');
    const playerVolSlider = document.getElementById('playerVolSlider');
    const mobsVolSlider = document.getElementById('mobsVolSlider');
    const uiVolSlider = document.getElementById('uiVolSlider');
    const masterVolValue = document.getElementById('masterVolValue');
    const blocksVolValue = document.getElementById('blocksVolValue');
    const playerVolValue = document.getElementById('playerVolValue');
    const mobsVolValue = document.getElementById('mobsVolValue');
    const uiVolValue = document.getElementById('uiVolValue');
    
    let isPaused = false;

    function togglePause() {
      isPaused = !isPaused;
      if (isPaused) {
        pauseMenu.classList.add('active');
        if (!TEST_MODE) controls.unlock();
        soundSystem.menuOpen();
      } else {
        pauseMenu.classList.remove('active');
        if (!TEST_MODE) controls.lock();
        soundSystem.menuClose();
      }
    }

    // Settings sliders
    sensitivitySlider.addEventListener('input', (e) => {
      settings.aimSensitivity = parseFloat(e.target.value);
      sensValue.textContent = settings.aimSensitivity.toFixed(1);
    });

    crosshairSlider.addEventListener('input', (e) => {
      settings.crosshairSize = parseInt(e.target.value);
      crosshairValue.textContent = settings.crosshairSize;
      crosshairEl.style.fontSize = settings.crosshairSize + 'px';
    });

    // FOV slider
    const fovSlider = document.getElementById('fovSlider');
    const fovValue = document.getElementById('fovValue');
    fovSlider.addEventListener('input', (e) => {
      const fov = parseInt(e.target.value);
      camera.fov = fov;
      camera.updateProjectionMatrix();
      fovValue.textContent = fov + '¬∞';
    });

    // Brightness slider
    const brightnessSlider = document.getElementById('brightnessSlider');
    const brightnessValue = document.getElementById('brightnessValue');
    brightnessSlider.addEventListener('input', (e) => {
      const brightness = parseInt(e.target.value);
      // Adjust ambient light intensity based on brightness
      ambientLight.intensity = 0.4 * (brightness / 100);
      brightnessValue.textContent = brightness + '%';
    });

    // Time of Day slider
    timeSlider.addEventListener('input', (e) => {
      timeOfDay = parseFloat(e.target.value);
      const hours = Math.floor(timeOfDay * 24);
      const mins = Math.floor((timeOfDay * 24 * 60) % 60);
      timeValueEl.textContent = `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
    });

    // Day Speed slider
    const speedLabels = ['‚è∏Ô∏è Paused', 'üê¢ Slow', 'üö∂ Normal', 'üöÄ Fast'];
    const speedMultipliers = [0, 0.25, 1, 4];
    speedSlider.addEventListener('input', (e) => {
      const speedIndex = parseInt(e.target.value);
      daySpeed = speedMultipliers[speedIndex];
      speedValueEl.textContent = speedLabels[speedIndex];
    });

    // Quick time buttons
    setDayBtn.addEventListener('click', () => {
      timeOfDay = 0.5; // Noon
      timeSlider.value = 0.5;
      timeValueEl.textContent = '12:00';
    });

    setNightBtn.addEventListener('click', () => {
      timeOfDay = 0.0; // Midnight
      timeSlider.value = 0.0;
      timeValueEl.textContent = '00:00';
    });

    resumeBtn.addEventListener('click', () => {
      soundSystem.buttonClick();
      togglePause();
    });
    
    // Save/Load buttons
    const saveBtn = document.getElementById('saveBtn');
    const loadBtn = document.getElementById('loadBtn');
    
    saveBtn.addEventListener('click', () => {
      soundSystem.buttonClick();
      saveGame();
    });
    
    loadBtn.addEventListener('click', () => {
      soundSystem.buttonClick();
      if (confirm('Load saved game? Current progress will be replaced.')) {
        loadGame();
        togglePause();
      }
    });

    // Sound volume sliders
    masterVolSlider.addEventListener('input', (e) => {
      soundSystem.setVolume('master', parseInt(e.target.value));
      masterVolValue.textContent = e.target.value + '%';
    });
    blocksVolSlider.addEventListener('input', (e) => {
      soundSystem.setVolume('blocks', parseInt(e.target.value));
      blocksVolValue.textContent = e.target.value + '%';
    });
    playerVolSlider.addEventListener('input', (e) => {
      soundSystem.setVolume('player', parseInt(e.target.value));
      playerVolValue.textContent = e.target.value + '%';
    });
    mobsVolSlider.addEventListener('input', (e) => {
      soundSystem.setVolume('mobs', parseInt(e.target.value));
      mobsVolValue.textContent = e.target.value + '%';
    });
    uiVolSlider.addEventListener('input', (e) => {
      soundSystem.setVolume('ui', parseInt(e.target.value));
      uiVolValue.textContent = e.target.value + '%';
    });

    // WASD aiming (rotate camera)
    let aimUp = false, aimDown = false, aimLeft = false, aimRight = false;

    // Controls
    document.addEventListener('keydown', e => {
      // Pause menu toggle (works anytime, closes crafting first)
      if (e.code === 'Escape' || e.code === 'KeyP') {
        if (isCrafting) {
          toggleCrafting();
        } else {
          togglePause();
        }
        return;
      }

      // Crafting menu toggle
      if (e.code === 'KeyC') {
        if (!isPaused && !isFurnaceOpen) toggleCrafting();
        return;
      }
      
      // Furnace menu toggle (R key)
      if (e.code === 'KeyR') {
        if (!isPaused && !isCrafting) toggleFurnace();
        return;
      }

      // Don't process game controls if paused or crafting or furnace
      if (isPaused || isCrafting || isFurnaceOpen) return;

      // Check if gameplay is active (either pointer locked or in test mode)
      const gameplayActive = TEST_MODE || controls.isLocked;
      
      switch (e.code) {
        // Arrow keys = MOVE
        case 'ArrowUp': moveForward = true; break;
        case 'ArrowDown': moveBackward = true; break;
        case 'ArrowLeft': moveLeft = true; break;
        case 'ArrowRight': moveRight = true; break;
        // WASD = AIM (rotate view)
        case 'KeyW': aimUp = true; break;
        case 'KeyS': aimDown = true; break;
        case 'KeyA': aimLeft = true; break;
        case 'KeyD': aimRight = true; break;
        // TEST MODE: Q/E for camera yaw rotation, T/G for pitch
        case 'KeyQ': if (TEST_MODE) testModeCamera.rotateLeft = true; break;
        case 'KeyE': if (TEST_MODE) testModeCamera.rotateRight = true; break;
        case 'KeyT': if (TEST_MODE) testModeCamera.rotateUp = true; break;
        case 'KeyG': if (TEST_MODE) testModeCamera.rotateDown = true; break;
        // Jump
        case 'Space': if (canJump) { velocity.y += 18; soundSystem.jump(); } canJump = false; break;
        // Mine with Z key (hold) - works in test mode too
        case 'KeyZ': if (gameplayActive) isMining = true; break;
        // Place block (X key) - works in test mode too
        case 'KeyX': if (gameplayActive) placeBlock(); break;
        // Eat food (F key)
        case 'KeyF': eatFood(); break;
        // Hotbar selection (1-9)
        case 'Digit1': selectSlot(0); break;
        case 'Digit2': selectSlot(1); break;
        case 'Digit3': selectSlot(2); break;
        case 'Digit4': selectSlot(3); break;
        case 'Digit5': selectSlot(4); break;
        case 'Digit6': selectSlot(5); break;
        case 'Digit7': selectSlot(6); break;
        case 'Digit8': selectSlot(7); break;
        case 'Digit9': selectSlot(8); break;
      }
    });
    document.addEventListener('keyup', e => {
      switch (e.code) {
        // Arrow keys = MOVE
        case 'ArrowUp': moveForward = false; break;
        case 'ArrowDown': moveBackward = false; break;
        case 'ArrowLeft': moveLeft = false; break;
        case 'ArrowRight': moveRight = false; break;
        // WASD = AIM
        case 'KeyW': aimUp = false; break;
        case 'KeyS': aimDown = false; break;
        case 'KeyA': aimLeft = false; break;
        case 'KeyD': aimRight = false; break;
        // TEST MODE: Q/E for camera yaw rotation, T/G for pitch
        case 'KeyQ': if (TEST_MODE) testModeCamera.rotateLeft = false; break;
        case 'KeyE': if (TEST_MODE) testModeCamera.rotateRight = false; break;
        case 'KeyT': if (TEST_MODE) testModeCamera.rotateUp = false; break;
        case 'KeyG': if (TEST_MODE) testModeCamera.rotateDown = false; break;
        // Stop mining
        case 'KeyZ': isMining = false; break;
      }
    });
    
    // Mouse down = start mining (left-click) or shoot (right-click)
    document.addEventListener('mousedown', (e) => {
      if (isPaused || isCrafting || e.target.closest('#pauseMenu') || e.target.closest('#craftingMenu')) return;
      const gameplayActive = TEST_MODE || controls.isLocked;
      if (gameplayActive) {
        if (e.button === 0) {
          isMining = true; // Left-click = mine
        } else if (e.button === 2) {
          shoot(); // Right-click = shoot!
        }
      }
    });
    
    // Prevent context menu on right-click (so we can shoot!)
    document.addEventListener('contextmenu', (e) => {
      const gameplayActive = TEST_MODE || controls.isLocked;
      if (gameplayActive) {
        e.preventDefault();
      }
    });
    
    // Mouse up = stop mining
    document.addEventListener('mouseup', (e) => {
      if (e.button === 0) {
        isMining = false;
      }
    });
    
    // Eat food function - works with any edible item
    function eatFood() {
      // First try to eat from selected slot
      const selectedSlot = inventory.slots[inventory.selectedSlot];
      if (selectedSlot && itemTypes[selectedSlot.type]?.isEdible) {
        const hungerValue = itemTypes[selectedSlot.type].hungerValue || 4;
        eat(hungerValue);
        soundSystem.eat();
        selectedSlot.count--;
        if (selectedSlot.count <= 0) inventory.slots[inventory.selectedSlot] = null;
        updateHotbarUI();
        updateHeldItem();
        showItemPickupPopup(selectedSlot.type, camera.position);
        return;
      }
      
      // Otherwise find any food in inventory
      for (let i = 0; i < inventory.slots.length; i++) {
        const slot = inventory.slots[i];
        if (slot && itemTypes[slot.type]?.isEdible) {
          const hungerValue = itemTypes[slot.type].hungerValue || 4;
          eat(hungerValue);
          soundSystem.eat();
          slot.count--;
          if (slot.count <= 0) inventory.slots[i] = null;
          updateHotbarUI();
          updateHeldItem();
          showItemPickupPopup(slot.type, camera.position);
          return;
        }
      }
    }

    // ===== TUTORIAL/WELCOME SYSTEM =====
    const tutorialScreen = document.getElementById('tutorialScreen');
    const startGameBtn = document.getElementById('startGameBtn');
    const TUTORIAL_KEY = 'jax_minecraft_played';
    
    function showTutorial() {
      tutorialScreen.classList.add('active');
    }
    
    function hideTutorial() {
      tutorialScreen.classList.remove('active');
      localStorage.setItem(TUTORIAL_KEY, 'true');
      soundSystem.init();
      soundSystem.craftSuccess(); // Happy sound!
      if (!TEST_MODE) {
        controls.lock();
      }
    }
    
    function hasPlayedBefore() {
      return localStorage.getItem(TUTORIAL_KEY) === 'true';
    }
    
    startGameBtn.addEventListener('click', hideTutorial);
    
    // Show tutorial on first visit (skip in test mode)
    if (TEST_MODE) {
      // Test mode: auto-start the game
      hideTutorial();
      console.log('üß™ Test mode: Tutorial skipped, game started');
    } else if (!hasPlayedBefore()) {
      showTutorial();
    }
    // ===== END TUTORIAL =====

    // ===== SAVE/LOAD SYSTEM =====
    const SAVE_KEY = 'jax_minecraft_save';
    const AUTOSAVE_INTERVAL = 60000; // Auto-save every 60 seconds
    
    function gatherSaveData() {
      return {
        version: 1,
        savedAt: Date.now(),
        player: {
          position: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
          health: playerStats.health,
          maxHealth: playerStats.maxHealth,
          hunger: playerStats.hunger,
          maxHunger: playerStats.maxHunger,
          score: score,
        },
        inventory: inventory.slots.map(slot => slot ? { type: slot.type, count: slot.count, durability: slot.durability } : null),
        selectedSlot: inventory.selectedSlot,
        world: {
          timeOfDay: timeOfDay,
        },
        playTime: Date.now() - breakConfig.playTimeStart + (breakConfig.totalPlayTime || 0),
      };
    }
    
    function saveGame() {
      try {
        const saveData = gatherSaveData();
        localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
        showNotification('üíæ Game saved!', 2000);
        console.log('Game saved successfully');
        return true;
      } catch (e) {
        console.error('Save failed:', e);
        showNotification('‚ùå Save failed!', 3000);
        return false;
      }
    }
    
    function loadGame() {
      try {
        const saveStr = localStorage.getItem(SAVE_KEY);
        if (!saveStr) {
          showNotification('üì≠ No save found', 2000);
          return false;
        }
        
        const saveData = JSON.parse(saveStr);
        
        // Restore player
        camera.position.set(saveData.player.position.x, saveData.player.position.y, saveData.player.position.z);
        playerStats.health = saveData.player.health;
        playerStats.maxHealth = saveData.player.maxHealth;
        playerStats.hunger = saveData.player.hunger;
        playerStats.maxHunger = saveData.player.maxHunger;
        score = saveData.player.score;
        scoreDisplay.textContent = score;
        
        // Restore inventory
        inventory.slots = saveData.inventory.map(slot => slot ? { type: slot.type, count: slot.count, durability: slot.durability } : null);
        inventory.selectedSlot = saveData.selectedSlot || 0;
        updateHotbarUI();
        updateHeldItem();
        
        // Restore world
        timeOfDay = saveData.world.timeOfDay;
        
        // Restore play time tracking
        breakConfig.totalPlayTime = saveData.playTime || 0;
        
        // Update status bars
        updateHealthUI();
        updateHungerUI();
        
        showNotification('‚úÖ Game loaded!', 2000);
        console.log('Game loaded successfully');
        return true;
      } catch (e) {
        console.error('Load failed:', e);
        showNotification('‚ùå Load failed!', 3000);
        return false;
      }
    }
    
    function hasSaveData() {
      return localStorage.getItem(SAVE_KEY) !== null;
    }
    
    function deleteSave() {
      localStorage.removeItem(SAVE_KEY);
      showNotification('üóëÔ∏è Save deleted', 2000);
    }
    
    function showNotification(message, duration = 3000) {
      // Create notification element if it doesn't exist
      let notif = document.getElementById('gameNotification');
      if (!notif) {
        notif = document.createElement('div');
        notif.id = 'gameNotification';
        notif.style.cssText = `
          position: fixed;
          top: 80px;
          left: 50%;
          transform: translateX(-50%);
          background: rgba(0, 0, 0, 0.8);
          color: #fff;
          padding: 15px 30px;
          font-family: 'Comic Sans MS', cursive;
          font-size: 18px;
          border: 3px solid #666;
          z-index: 9999;
          transition: opacity 0.3s;
        `;
        document.body.appendChild(notif);
      }
      
      notif.textContent = message;
      notif.style.opacity = '1';
      notif.style.display = 'block';
      
      setTimeout(() => {
        notif.style.opacity = '0';
        setTimeout(() => { notif.style.display = 'none'; }, 300);
      }, duration);
    }
    
    // Auto-save
    setInterval(() => {
      if (!isPaused && !deathScreen.classList.contains('active')) {
        saveGame();
      }
    }, AUTOSAVE_INTERVAL);
    
    // Save on page unload
    window.addEventListener('beforeunload', () => {
      saveGame();
    });
    
    // Try to load game on start (after a short delay to ensure game is initialized)
    setTimeout(() => {
      if (hasSaveData()) {
        loadGame();
      }
    }, 500);
    // ===== END SAVE/LOAD SYSTEM =====

    // ===== BREAK REMINDER SYSTEM =====
    const breakReminder = document.getElementById('breakReminder');
    const breakOkBtn = document.getElementById('breakOkBtn');
    const playTimeDisplay = document.getElementById('playTimeDisplay');
    
    const breakConfig = {
      enabled: true,
      intervalMinutes: 30,        // Remind every 30 minutes
      playTimeStart: Date.now(),
      lastReminderAt: 0,
      totalPlayTime: 0,           // In milliseconds
    };
    
    function checkBreakReminder() {
      if (!breakConfig.enabled) return;
      
      const now = Date.now();
      const playTimeMs = now - breakConfig.playTimeStart;
      const playTimeMinutes = playTimeMs / 60000;
      
      // Check if it's time for a break
      const remindersDue = Math.floor(playTimeMinutes / breakConfig.intervalMinutes);
      
      if (remindersDue > breakConfig.lastReminderAt && !isPaused && !isCrafting && !isFurnaceOpen) {
        breakConfig.lastReminderAt = remindersDue;
        showBreakReminder(playTimeMinutes);
      }
    }
    
    function showBreakReminder(minutes) {
      breakReminder.classList.add('active');
      playTimeDisplay.textContent = `Play time: ${Math.floor(minutes)} minutes üéÆ`;
      controls.unlock();
      soundSystem.menuOpen();
    }
    
    function hideBreakReminder() {
      breakReminder.classList.remove('active');
      soundSystem.buttonClick();
      if (!isPaused && !isCrafting && !isFurnaceOpen && !deathScreen.classList.contains('active')) {
        controls.lock();
      }
    }
    
    breakOkBtn.addEventListener('click', hideBreakReminder);
    
    // Check every 10 seconds
    setInterval(checkBreakReminder, 10000);
    // ===== END BREAK REMINDER =====

    // Animation loop
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      // Update invulnerability timer
      if (invulnerabilityTimer > 0) {
        invulnerabilityTimer -= delta;
      }
      
      // Void death check (fell below Y = -50)
      if (camera.position.y < -50 && player.health > 0) {
        die('void');
        return;
      }

      // Day/night cycle (always runs)
      updateDayNightCycle(delta);

      // Animate water (always runs, even when paused - looks nice!)
      animateWater(delta);

      // Animate dropped items (bobbing, spinning, magnetic pickup)
      animateDroppedItems(delta);

      // Update mobs (AI, animation, spawning)
      updateMobs(delta);
      updateHostileMobs(delta);

      // Mining system
      updateMining(delta);
      
      // Swing animation (mining/attack "hack" motion)
      updateSwingAnimation(delta);
      
      // Furnace smelting (runs even when not looking at it)
      updateFurnace(delta);
      
      // Don't process gameplay when dead
      if (deathScreen.classList.contains('active')) {
        renderer.render(scene, camera);
        return;
      }

      // Check if we should process gameplay (either pointer locked or in test mode)
      const gameplayActive = TEST_MODE || controls.isLocked;
      
      if (gameplayActive && !isPaused && !isCrafting) {
        // ===== TEST MODE CAMERA ROTATION =====
        // In test mode, use keyboard for camera rotation (Q/E for yaw, T/G for pitch)
        if (TEST_MODE) {
          const rotSpeed = testModeCamera.sensitivity * 2;
          
          if (testModeCamera.rotateLeft) {
            testModeCamera.yaw += rotSpeed;
          }
          if (testModeCamera.rotateRight) {
            testModeCamera.yaw -= rotSpeed;
          }
          if (testModeCamera.rotateUp) {
            testModeCamera.pitch += rotSpeed * 0.5;
            testModeCamera.pitch = Math.min(testModeCamera.pitch, Math.PI / 2 - 0.1);
          }
          if (testModeCamera.rotateDown) {
            testModeCamera.pitch -= rotSpeed * 0.5;
            testModeCamera.pitch = Math.max(testModeCamera.pitch, -Math.PI / 2 + 0.1);
          }
          
          // Apply rotation to camera
          camera.rotation.order = 'YXZ';
          camera.rotation.y = testModeCamera.yaw;
          camera.rotation.x = testModeCamera.pitch;
        }
        // ===== END TEST MODE CAMERA ROTATION =====
        
        // WASD aiming - simulate mouse movement for PointerLockControls
        // This works properly with the controls instead of conflicting
        const aimSpeed = settings.aimSensitivity * 50; // Scale for smooth movement
        
        if (!TEST_MODE && (aimLeft || aimRight || aimUp || aimDown)) {
          // Create synthetic mouse movement
          const movementX = (Number(aimRight) - Number(aimLeft)) * aimSpeed * delta;
          const movementY = (Number(aimDown) - Number(aimUp)) * aimSpeed * delta;
          
          // Dispatch synthetic pointermove event that PointerLockControls listens to
          const event = new MouseEvent('mousemove', {
            movementX: movementX,
            movementY: movementY
          });
          document.dispatchEvent(event);
        }

        // Arrow key movement with COLLISION DETECTION
        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.normalize();

        velocity.x -= velocity.x * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;
        velocity.y -= 25.0 * delta; // gravity

        if (direction.z || direction.x) {
          // Save current position
          const oldPos = camera.position.clone();
          
          if (TEST_MODE) {
            // Test mode: implement movement manually based on camera rotation
            const moveSpeed = 20 * delta;
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();
            
            const right = new THREE.Vector3();
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
            
            camera.position.addScaledVector(forward, direction.z * moveSpeed);
            camera.position.addScaledVector(right, direction.x * moveSpeed);
          } else {
            // Normal mode: use PointerLockControls
          controls.moveRight(direction.x * 20 * delta);
          controls.moveForward(direction.z * 20 * delta);
          }
          
          // Check for collision and resolve
          const newPos = camera.position.clone();
          const resolvedPos = tryMove(oldPos, newPos);
          
          // Apply resolved position
          camera.position.x = resolvedPos.x;
          camera.position.z = resolvedPos.z;
        }

        camera.position.y += velocity.y * delta;
        
        // ===== GROUND DETECTION (Minecraft-style block snapping!) =====
        const playerX = camera.position.x;
        const playerZ = camera.position.z;
        const playerFeet = camera.position.y - 4; // Player feet position (4 units below eyes)
        
        // Always generate ground blocks near player (ensures terrain exists under them)
        ensureGroundBlocksNear(playerX, playerZ);
        
        // Start with a low fallback (void level) - will find actual blocks
        let groundHeight = -100;
        let foundBlock = false;
        
        // Helper function to check all block types for ground
        // Minecraft-style: land on block if within horizontal bounds and player above block
        function checkBlocksForGround(blockArray) {
          for (const block of blockArray) {
            const dx = playerX - block.position.x;
            const dz = playerZ - block.position.z;
            const horizDist = Math.sqrt(dx * dx + dz * dz);
            
            // If player is within horizontal bounds of block (block is 4 units wide, use 2.8 for margin)
            if (horizDist < 2.8) {
              const blockTop = block.position.y + 2; // Top of block (center + half height)
              const newGroundHeight = blockTop + 4; // Eye height when standing on this block
              
              // Land on this block if:
              // 1. Player feet are at or above block top (can land when falling onto it)
              //    Allow margin for stepping up small heights (like Minecraft auto-step)
              // 2. This would be higher ground than current (find highest valid block)
              // Key: Only land on blocks where feet are AT or ABOVE the top
              const canLandOn = playerFeet >= blockTop - 1.0; // 1 unit margin for step-up
              const isHigherGround = newGroundHeight > groundHeight;
              
              if (canLandOn && isHigherGround) {
                groundHeight = newGroundHeight;
                foundBlock = true;
              }
            }
          }
        }
        
        // Check placed blocks first (they take priority), then ground blocks
        checkBlocksForGround(blocks);
        checkBlocksForGround(groundBlocks);
        
        // Safety: if no block found, use grass level fallback only if player is above void
        if (!foundBlock) {
          if (playerFeet > -10) {
            groundHeight = 8; // Fallback to grass level
          } else {
            groundHeight = -100; // Void - will trigger death
          }
        }
        
        // Check if player is in water (negates fall damage)
        const inWater = lake && 
          camera.position.x > lake.position.x - 17.5 && camera.position.x < lake.position.x + 17.5 &&
          camera.position.z > lake.position.z - 12.5 && camera.position.z < lake.position.z + 12.5 &&
          camera.position.y < 5;
        
        // ===== MINECRAFT-STYLE FALL DAMAGE =====
        // Track when player starts falling
        if (velocity.y < 0 && !player.isFalling) {
          player.isFalling = true;
        }
        
        if (camera.position.y <= groundHeight) {
          // Landed on ground!
          // Calculate fall damage: how far did we fall from our LAST STANDING POSITION?
          // This is the key: we compare to lastGroundY, not the apex of the jump!
          const SAFE_FALL_DISTANCE = 3; // No damage for falls <= 3 blocks
          const MAX_FALL_DAMAGE = 20;
          
          // Fall distance is from last ground position to current ground position
          // Only count if we actually FELL (lastGroundY > groundHeight)
          const fallDistance = player.lastGroundY - groundHeight;
          
          if (!inWater && player.isFalling && fallDistance > SAFE_FALL_DISTANCE) {
            const damage = Math.min(Math.floor(fallDistance - SAFE_FALL_DISTANCE), MAX_FALL_DAMAGE);
            takeDamage(damage, 'fall');
            soundSystem.landHard(); // Hard landing with damage
            
            // Spawn landing dust particles
            for (let i = 0; i < 8; i++) {
              const dust = new THREE.Mesh(
                new THREE.SphereGeometry(0.15),
                new THREE.MeshBasicMaterial({ color: 0x8B4513, transparent: true, opacity: 0.7 })
              );
              dust.position.set(
                camera.position.x + (Math.random() - 0.5) * 2,
                groundHeight - 4,
                camera.position.z + (Math.random() - 0.5) * 2
              );
              scene.add(dust);
              
              const dustVel = new THREE.Vector3(
                (Math.random() - 0.5) * 3,
                Math.random() * 2,
                (Math.random() - 0.5) * 3
              );
              let dustLife = 0;
              const dustTimer = setInterval(() => {
                dust.position.add(dustVel.clone().multiplyScalar(0.05));
                dustVel.y -= 0.1;
                dust.material.opacity -= 0.05;
                dustLife++;
                if (dustLife > 15) {
                  scene.remove(dust);
                  clearInterval(dustTimer);
                }
              }, 50);
            }
          } else if (player.isFalling && Math.abs(camera.position.y - groundHeight) > 0.5 && !inWater) {
            soundSystem.land(); // Normal landing sound
          } else if (inWater && fallDistance > 3) {
            soundSystem.land(); // Splash sound
          }
          
          // Update lastGroundY to current ground (for next fall calculation)
          // Only update if we're on HIGHER ground (climbing up resets fall tracking)
          if (groundHeight >= player.lastGroundY) {
            player.lastGroundY = groundHeight;
          } else if (player.isFalling) {
            // Landed on lower ground - update for next fall
            player.lastGroundY = groundHeight;
          }
          
          // Reset fall tracking
          player.isFalling = false;
          velocity.y = 0;
          camera.position.y = groundHeight;
          canJump = true;
        }
        // ===== END FALL DAMAGE =====
      }

      // Update bullets and check for hits!
      for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];
        bullet.position.addScaledVector(bullet.velocity, delta);
        
        // ===== BOUNCE PHYSICS =====
        let bounced = false;
        
        // Check ground bounce (y < 0.5)
        if (bullet.position.y < 0.5 && bullet.velocity.y < 0) {
          bullet.position.y = 0.5;
          bullet.velocity.y = -bullet.velocity.y; // Reflect Y
          bullet.velocity.multiplyScalar(BULLET_BOUNCE_ENERGY_LOSS);
          bullet.bounceCount++;
          bounced = true;
          // Distance-based ricochet sound (quieter when farther away!)
          const distToPlayer = bullet.position.distanceTo(camera.position);
          soundSystem.ricochet(distToPlayer);
        }
        
        // Check block surface bounces using raycast
        if (!bounced) {
          const bulletRay = new THREE.Raycaster(
            bullet.position.clone(),
            bullet.velocity.clone().normalize(),
            0, 1.5 // Check 1.5 units ahead
          );
          const blockHits = bulletRay.intersectObjects(blocks);
          
          if (blockHits.length > 0 && blockHits[0].distance < 1.5) {
            const hit = blockHits[0];
            const hitBlock = hit.object;
            
            // Track blocks this bullet has hit
            if (!bullet.hitBlocks) bullet.hitBlocks = new Set();
            
            // Check if we've hit this block before - DESTROY IT!
            if (bullet.hitBlocks.has(hitBlock)) {
              // BOOM! Destroy block on second hit!
              soundSystem.explosion();
              const blockIdx = blocks.indexOf(hitBlock);
              if (blockIdx > -1) {
                const blockPos = hitBlock.position.clone();
                const blockColor = hitBlock.material.color.getHex();
                
                // Sparkle explosion!
                for (let s = 0; s < 8; s++) {
                  const spark = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3),
                    new THREE.MeshBasicMaterial({ color: 0xffff00 })
                  );
                  spark.position.copy(blockPos);
                  scene.add(spark);
                  const sparkVel = new THREE.Vector3(
                    (Math.random() - 0.5) * 15,
                    Math.random() * 10,
                    (Math.random() - 0.5) * 15
                  );
                  spark.userData.vel = sparkVel;
                  spark.userData.life = 0;
                  const sparkTimer = setInterval(() => {
                    spark.position.add(spark.userData.vel.clone().multiplyScalar(0.05));
                    spark.userData.vel.y -= 0.5;
                    spark.userData.life++;
                    if (spark.userData.life > 20) {
                      scene.remove(spark);
                      clearInterval(sparkTimer);
                    }
                  }, 50);
                }
                
                // Drop item and remove block
                spawnDroppedItem('stone', blockPos, blockColor);
                scene.remove(hitBlock);
                blocks.splice(blockIdx, 1);
                
                // Score!
                score++;
                scoreDisplay.textContent = score;
                showScorePopup(blockPos);
                
                // Spawn new block
                setTimeout(spawnRandomBlock, 2000);
              }
              
              scene.remove(bullet);
          bullets.splice(i, 1);
              continue;
            }
            
            // First hit - bounce off!
            bullet.hitBlocks.add(hitBlock);
            
            const normal = hit.face.normal.clone();
            // Transform normal to world space
            normal.transformDirection(hit.object.matrixWorld);
            
            // Reflect velocity: v' = v - 2(v¬∑n)n
            const dot = bullet.velocity.dot(normal);
            bullet.velocity.sub(normal.multiplyScalar(2 * dot));
            bullet.velocity.multiplyScalar(BULLET_BOUNCE_ENERGY_LOSS);
            
            // Move bullet slightly away from surface
            bullet.position.add(hit.face.normal.clone().transformDirection(hit.object.matrixWorld).multiplyScalar(0.3));
            
            bullet.bounceCount++;
            bounced = true;
            // Distance-based ricochet sound
            const bounceDistToPlayer = bullet.position.distanceTo(camera.position);
            soundSystem.ricochet(bounceDistToPlayer);
          }
        }
        
        // Remove bullet if max bounces or too slow
        const speed = bullet.velocity.length();
        if (bullet.bounceCount >= bullet.maxBounces || speed < BULLET_MIN_SPEED) {
          // Final hit - create small spark effect
          const spark = new THREE.Mesh(
            new THREE.SphereGeometry(0.2),
            new THREE.MeshBasicMaterial({ color: 0xff8800 })
          );
          spark.position.copy(bullet.position);
          scene.add(spark);
          setTimeout(() => scene.remove(spark), 100);
          
          scene.remove(bullet);
          bullets.splice(i, 1);
          continue;
        }
        
        // Remove bullet if it goes too far (out of world)
        if (bullet.position.length() > 500) {
          scene.remove(bullet);
          bullets.splice(i, 1);
          continue;
        }
        // ===== END BOUNCE PHYSICS =====
        
        // ===== SELF-DAMAGE & FLYBY SOUNDS =====
        // Only check after bullet has bounced at least once (so you don't shoot yourself)
        if (bullet.bounceCount > 0) {
          const distToPlayer = bullet.position.distanceTo(camera.position);
          
          // Check if bullet hit the player!
          if (distToPlayer < 1.5) {
            soundSystem.ricochetHit(); // Ouch sound!
            takeDamage(3, 'ricochet'); // Ouch! Shot yourself!
            scene.remove(bullet);
            bullets.splice(i, 1);
            continue;
          }
          
          // Flyby sound when bullet passes close (within 3 units, but not too close)
          if (distToPlayer < 3 && distToPlayer > 1.5 && !bullet.playedFlyby) {
            bullet.playedFlyby = true;
            // Play flyby "whoosh" sound
            soundSystem.playFlyby();
          }
        }
        // ===== END SELF-DAMAGE & FLYBY =====
        
        // Check if bullet hit any passive mob
        const hitMob = checkMobHit(bullet.position, 1.5);
        if (hitMob) {
          damageMob(hitMob, 4); // Bullets do 4 damage
          scene.remove(bullet);
          bullets.splice(i, 1);
          continue;
        }
        
        // Check if bullet hit any hostile mob
        const hitHostile = checkHostileMobHit(bullet.position, 1.5);
        if (hitHostile) {
          damageHostileMob(hitHostile, 4); // Bullets do 4 damage
          scene.remove(bullet);
          bullets.splice(i, 1);
          continue;
        }

        // Bullets now BOUNCE off blocks instead of destroying them!
        // (Block destruction is handled by the bounce physics above - bullets ricochet)
        // Use mining (Z key) to break blocks instead.

        // ===== SHOOT-TO-PICKUP: Hit dropped items to collect them! =====
        for (let d = droppedItems.length - 1; d >= 0; d--) {
          const droppedItem = droppedItems[d];
          if (bullet.position.distanceTo(droppedItem.position) < 2) {
            // Pick up the item!
            const itemType = droppedItem.userData.itemType;
            const count = droppedItem.userData.count || 1;
            
            if (addToInventory(itemType, count)) {
              // Success! Show pickup effect
              soundSystem.itemPickup();
              showItemPickupPopup(itemType, droppedItem.position);
              
              // Sparkle effect when shot
              for (let s = 0; s < 5; s++) {
                const spark = new THREE.Mesh(
                  new THREE.SphereGeometry(0.15),
                  new THREE.MeshBasicMaterial({ color: 0x00ff00 })
                );
                spark.position.copy(droppedItem.position);
                scene.add(spark);
                const sparkVel = new THREE.Vector3(
                  (Math.random() - 0.5) * 8,
                  Math.random() * 6,
                  (Math.random() - 0.5) * 8
                );
                spark.userData.vel = sparkVel;
                spark.userData.life = 0;
                const sparkTimer = setInterval(() => {
                  spark.position.add(spark.userData.vel.clone().multiplyScalar(0.05));
                  spark.userData.vel.y -= 0.3;
                  spark.userData.life++;
                  if (spark.userData.life > 12) {
                    scene.remove(spark);
                    clearInterval(sparkTimer);
                  }
                }, 50);
              }
              
              // Remove item and bullet
              scene.remove(droppedItem);
              droppedItems.splice(d, 1);
              scene.remove(bullet);
              bullets.splice(i, 1);
              break;
            }
          }
        }
        // ===== END SHOOT-TO-PICKUP =====

        // Check if bullet hit any tree part (trunk or leaf)
        for (let t = treeParts.length - 1; t >= 0; t--) {
          const part = treeParts[t];
          if (!part.parent) continue; // Already removed
          
          // Get world position of the tree part
          const partWorldPos = new THREE.Vector3();
          part.getWorldPosition(partWorldPos);
          
          if (bullet.position.distanceTo(partWorldPos) < 1.5) {
            // Determine spark color based on part type
            const sparkColor = part.userData.type === 'leaf' ? 0x228B22 : 0x8B4513;
            
            // Explosion sparks!
            for (let s = 0; s < 6; s++) {
              const spark = new THREE.Mesh(
                new THREE.SphereGeometry(0.2),
                new THREE.MeshBasicMaterial({ color: sparkColor })
              );
              spark.position.copy(partWorldPos);
              scene.add(spark);
              
              const sparkVel = new THREE.Vector3(
                (Math.random() - 0.5) * 10,
                Math.random() * 8,
                (Math.random() - 0.5) * 10
              );
              spark.userData.vel = sparkVel;
              spark.userData.life = 0;
              
              const sparkTimer = setInterval(() => {
                spark.position.add(spark.userData.vel.clone().multiplyScalar(0.05));
                spark.userData.vel.y -= 0.4;
                spark.userData.life++;
                if (spark.userData.life > 15) {
                  scene.remove(spark);
                  clearInterval(sparkTimer);
                }
              }, 50);
            }

            // Drop item from tree part!
            const dropType = part.userData.type === 'leaf' ? 'leaves' : 'wood';
            spawnDroppedItem(dropType, partWorldPos);

            // Remove the tree part
            const parentTree = part.userData.parentTree;
            if (parentTree) {
              parentTree.remove(part);
            }
            treeParts.splice(t, 1);
            
            // Remove bullet
            scene.remove(bullet);
            bullets.splice(i, 1);

            // Score for tree parts too!
            score++;
            scoreDisplay.textContent = score;
            showScorePopup(partWorldPos);
            
            break;
          }
        }

        // Check if bullet hit any cave part (stone or treasure)
        for (let c = caveParts.length - 1; c >= 0; c--) {
          const part = caveParts[c];
          if (!part.parent) continue; // Already removed
          
          const partWorldPos = new THREE.Vector3();
          part.getWorldPosition(partWorldPos);
          
          if (bullet.position.distanceTo(partWorldPos) < 1.5) {
            // Different effects for stone vs treasure
            const isTreasure = part.userData.type === 'treasure';
            const sparkColor = isTreasure ? 0xffd700 : 0x888888; // Gold or gray
            const sparkCount = isTreasure ? 12 : 5;
            
            for (let s = 0; s < sparkCount; s++) {
              const spark = new THREE.Mesh(
                new THREE.SphereGeometry(isTreasure ? 0.3 : 0.15),
                new THREE.MeshBasicMaterial({ color: sparkColor })
              );
              spark.position.copy(partWorldPos);
              scene.add(spark);
              
              const sparkVel = new THREE.Vector3(
                (Math.random() - 0.5) * (isTreasure ? 15 : 8),
                Math.random() * (isTreasure ? 12 : 6),
                (Math.random() - 0.5) * (isTreasure ? 15 : 8)
              );
              spark.userData.vel = sparkVel;
              spark.userData.life = 0;
              
              const sparkTimer = setInterval(() => {
                spark.position.add(spark.userData.vel.clone().multiplyScalar(0.05));
                spark.userData.vel.y -= 0.4;
                spark.userData.life++;
                if (spark.userData.life > 18) {
                  scene.remove(spark);
                  clearInterval(sparkTimer);
                }
              }, 50);
            }

            // Drop item from cave part!
            const caveDropType = isTreasure ? 'treasure' : 'stone';
            spawnDroppedItem(caveDropType, partWorldPos);

            // Remove cave part
            const parentCave = part.userData.parentCave;
            if (parentCave) {
              parentCave.remove(part);
            }
            caveParts.splice(c, 1);
            
            // Remove bullet
            scene.remove(bullet);
            bullets.splice(i, 1);

            // More points for treasure!
            const points = isTreasure ? 5 : 1;
            score += points;
            scoreDisplay.textContent = score;
            
            // Custom popup for treasure
            const popup = document.createElement('div');
            popup.className = 'score-popup';
            popup.textContent = isTreasure ? 'TREASURE! +5' : 'Score +1!';
            popup.style.color = isTreasure ? '#ffd700' : '#ffff00';
            const pos = partWorldPos.clone().project(camera);
            popup.style.left = ((pos.x * 0.5 + 0.5) * window.innerWidth) + 'px';
            popup.style.top = ((-pos.y * 0.5 + 0.5) * window.innerHeight) + 'px';
            document.body.appendChild(popup);
            setTimeout(() => popup.remove(), 2000);
            
            break;
          }
        }

        // Remove bullets that fly too far
        if (bullet.position.length() > 200) {
          scene.remove(bullet);
          bullets.splice(i, 1);
        }
      }

      renderer.render(scene, camera);
    }
    animate();

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>